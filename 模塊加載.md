##原始時代
作爲一門語言的引入代碼方式,相較於其他如PHP的include和require,Ruby的require,Python的import機制,Javascript是直接使用<script>標簽,因为Javascript是一门单线程语言,GUI渲染线程和Javascript引擎线程是互斥的,代码执行到<script>标签GUI渲染线程会挂起,然后下载资源,执行脚本,完成之后再继续往下执行.在那段时间内界面是不会响应用户操作的.用户体验相当不友好.同时还帶來一系列的隱患:
1, 引入順序可能會引起代碼無效甚至報錯;
2, 互不瞭解的代碼也許會造成重複命名覆蓋;
3, 難以串聯代碼之間邏輯關係;
4, 執行順序受影響的因素更多;
5, 不易管理;

<script>标签也提供了defer和async属性可以异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令,区别在于:
defer: 等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行,可以保证顺序加载;
async: 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染,不保证顺序加载;
<script src="xx.js" defer></script>
<script src="xx.js" async></script>

出于需要社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。

##CommonJS規範
CommonJS規範為Javascript制定的美好願景是希望Javascript能夠在任何地方運行,具備跨宿主環境執行的能力,例如:
* 富客戶端應用
*  服務器端Javascript應用程序(如Nodejs)
* 命令行工具
* 桌面圖形界面應用程序
* 混合應用(Titanium和Adobe AIR等形式應用)
這些規範基本覆蓋了模塊,二進制,Buffer,字符集編碼,I/O流,進程環境,文件系統,套接字,單元測試,Web服務器網關接口,包管理等.


##CommonJS加载原理
第一次require()一个脚本的时候会执行然后在内存中会生成一个模块对象缓存起来,类似
{
  id: '...',//模块id
  exports: { ... },//导出变量
  loaded: true,//是否执行完
  ...
}
以后需要引用模块的变量就在这个模块对象的exports取出,即使再次require()进来模块也不会执行,只会从这里获取.


###模塊規範
1, 引用
模塊中上下文提供require方法引入外部模塊,Nodejs引入文件一般如下
var fs = require('fs');

2, 定義
模塊中存在一個上下文module對象,他代表模塊自身,module提供了exports對象用於導出當前模塊的方法變量,并且是唯一的導出出口
//a.js模塊
exports.a = 1;
//引用a.js模塊
var a = require('a');

3, 標識
require()方法接受小駝峰命名的字符串,或者相對/絕對路徑,并且可以省略文件後綴,有自己一套匹配規則後面再講.
至此看來使用相當簡單,模塊的意義在於將類聚的方法變量等限定在私有作用域中,同時支持引入導出功能鏈接上下游依賴,避免了變量污染等問題.

module.exports和exports的關係?
exports是引用module.exports的值,而真正導出的module.exports,接著就是基本類型和引用類型的區別了.
如果直接替換module.exports或者exports相當於切斷了和原有對象之間的關聯,後續兩者互不影響了.



Nodejs模塊實現
Nodejs借鋻了CommonJS但不完全按照規範實現了自己的模塊系統.在Nodejs中有兩種模塊
* Nodejs提供的核心模塊;
    這部分模塊在Nodejs源代碼編譯過程中編譯進了二進制執行文件.在Nodejs進程啓動時部分核心模塊被直接加載進了内存中,所以在引用的時候可以省去文件定位和編譯執行的步驟,并且在路徑分析優先判斷,所以加載速度是最快的.

* 由用戶編寫的文件模塊;
    這部分模塊在運行時動態加載,需要經歷完整步驟.

在Nodejs引入模塊會經歷三個步驟:
1, 路徑分析;
2, 文件定位;
3, 編譯執行;
Nodejs會對引用過的模塊進行緩存以減少二次引入的開銷.而且緩存的是模塊編譯和執行之後的對象.所以require對相同模塊的二次加載都是優先緩存方式,核心模塊的緩存檢查依然優先文件模塊.

###路徑分析
前面提過的模塊標識,例如:
* 核心模塊fs等
    優先級僅次於緩存加載,如果有引用自己編寫的相同標識模塊會失敗,必須選擇不同標識符或者使用路徑方式加載.

* 路徑形式文件模塊
分析過程中rerquire()會將路徑轉換成真實路徑,並以此為索引將編譯后結果緩存起來,因爲指明了模塊位置所以查找過程會省點時間,速度慢于核心模塊.

* 自定義模塊
    可能是以包還活著文件形式的特殊模塊,查找費時速度最慢的一種.因爲他會用到模塊路徑的查找方法.


###模塊路徑規則
你可以隨便一個文件夾執行一個脚本如下看看打印信息,我是Windows系統結果如下
console.log(module.paths);
[ 'C:\\work\\project\\test\\node_modules',
  'C:\\work\\project\\node_modules',
  'C:\\work\\node_modules',
  'C:\\node_modules' ]

從中可以看出他會從當前執行文件所在目錄下的node_modules,沿路徑向上逐層遞歸查找node_modules知道根目錄爲止.
模塊加載過程會逐個嘗試直到符合條件或者沒有符合爲止.
1, 層級越深查找起來越費時費力;
2, 可能你衹想查看當前目錄,但是它失敗后會自動嘗試其他路徑;
這就是自定義模塊最慢的原因.

###文件定位
* 擴展名分析
    Nodejs在標識符不包含後綴情況下會以.js, .json, .node的次序逐個嘗試匹配,而且過程中需要利用fs模塊以同步阻塞方式去判斷是否匹配,所以在非.js文件情況指明後綴會減少性能問題.

* 目錄分析和包
    還有一種情況是經過上面步驟之後都匹配不到對應文件但是有符合的目錄,此時Nodejs會將其作爲一個包的方式處理.
    1), 查找包下的package.json文件(包描述文件),通過JSON.parse()解析出文件讀取裏面的main屬性定位對應的文件.可能需要擴展名分析步驟.
    2) 如果沒有package.json或者main屬性不對,用默認值index去查找匹配文件,這一步需要擴展名分析步驟逐個嘗試.
    3) 如果還是失敗就會根據模塊路徑規則往上層路徑尋找.直到全部路徑都沒有匹配文件就抛出失敗.


##模塊編譯
這是引入模塊的最後階段,定位到目標文件之後會新建一個模塊對象,然後根據路徑載入進行編譯,不同後綴文件載入方式不同:
* js通過fs模塊同步讀取文件之後編譯執行
* node是C/C++編寫的擴展文件,通過dlopen()方法加載最後編譯生成的對象
* json通過fs模塊同步讀取文件之後用JSON.parse()解析返回結果
* 其餘默認js處理方式

每個編譯成功之後的模塊都會以其文件路徑作爲索引緩存在Module_cache.根據不同的擴展後綴Nodejs有不同的讀取方式.

1, Javascript模塊編譯
在編譯過程中,Nodejs會對獲取的模塊進行包裝,如下:
(function(exports, require, module, __filename, __dirname) {
    //模块源码
})

每個模塊都有各自獨立的作用域,exports上的所有方法屬性都能被外部使用

2, C/C++模塊編譯
Nodejs調用process.dlopen()方法進行加載執行,通過libuv封裝庫支持Windows和*nix平臺下實現,因爲.node本身就是C/C++寫的,所以它不需要編譯,衹要加載執行就可以了,所以執行效率較高.

3, JSON文件編譯
上面説過通過fs模塊同步讀取文件之後用JSON.parse()解析返回結果,賦值給模塊對象的exports.
除了配置文件,如果你開發中有需要用到json文件的時候可以不用fs模塊去讀取,而是直接require()引入更好,因爲能享受到緩存加載的便利.




##核心模塊
上面説過Nodejs模塊分爲核心模塊和文件模塊,剛才講的都是文件模塊的編譯過程,而Nodejs的核心模塊在編譯成可執行文件過程中會被編譯進二進制文件.核心模塊也分Javascript和C/C++編寫,前者在Node的lib目錄,後者在Node的src目錄.

###Javascript核心模塊編譯
1, 轉存為C/C++代碼
Nodejs采用V8附帶的js2c.py工具將内置的Javascript代碼(src/node.js和lib/*.js)轉成C++的數組,生成node_natives.h頭文件,Javascript代碼以字符串形式存儲在nodejs命名空間裏,此時還不能直接執行.
儅Nodejs啓動進程時候才被直接加載進内存中.所以不需要引入就能直接使用.

2, 編譯Javascript核心模塊
和文件模塊一樣也會被包裝成模塊對象,區別在於獲取源代碼的方式以及緩存執行結果的位置.
核心模塊源文件通過process.binding('natives')取出,編譯完成後緩存到NativeModule._cache對象上,文件模塊被緩存到Module._cache


###C/C++核心模塊編譯(不懂C/C++,這一塊簡短略過)
1, 内建模塊的組織形式
每個内建模塊在定義之後會通過NODE_MODULE宏將模塊定義到nodejs命名空間,模塊的具體初始化方法被挂載在結構的register_func成員.
node_extensions.h文件將散列的内建模塊統一放進node_module_list數組中,Nodejs提供了get_builtin_module()方法從中取出.
内建模塊優勢在於本身C/C++編寫性能優異,編譯成二進制文件時候被直接加載進内存,無需在做標識符定位,文件定位,編譯等過程.

2, 内建模塊導出
Nodejs啓動會生成全局變量process,提供Binding()方法協助加載内建模塊.
加載過程中我們會先生成exports空對象,然後調用get_builtin_module()方法去除内建模塊,通過執行register_func填充空對象,最後按模塊名緩存起來並返回給調用方使用.

3, 核心模塊引入流程




##模塊調用
至此我們已經有個大概概念了,梳理一下各種模塊之間的關係
C/C++内建模塊是最底層核心模塊主要提供API給Javascript核心模塊和第三方Javascript模塊使用.
Javascript核心模塊分兩類,一種作爲C/C++内建模塊的封裝層和橋接層,一類純粹的功能模塊.
文件模塊分Javascript模塊和C/C++擴展模塊.



##ES6模块加载
直到ES6标准化模块功能,统一替代了之前多种模块实现库,成为浏览器和服务器通用的模块解决方案.ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。
ES6 的模块有几个需要注意的地方:
1, 自动采用严格模式，即使你没有使用"use strict";
2, 顶层的this指向undefined;

// CommonJS模块
let {readFile} = require('fs');
// ES6模块
import {readFile} from 'fs';
以上为例.
CommonJS是加载整个fs模块生成一个模块对象,然后从对象中导出readFile方法.
ES6 模块通过export命令显式指定输出的代码，再通过import命令输入只从fs模块加载输入的方法属性.
结果就是ES6模块效率高,但是拿不到模块本身.
|加载方案|加载|输出|
---
|CommonJS|运行时加载|拷贝|
|ES6 模块|编译时输出接口|引用|

由于 ES6 模块是编译时加载，使得静态分析成为可能。比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。
ES6 模块还有以下好处:
不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。
将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。
不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。
ES6模块提供了export导出命令和import 导入命令,它们同样具有全局提升的效果,只要在顶层使用即可.


###export导出命令
支持输出变量,方法和类
//变量
export var a = 1;
//方法
export function log(n) {
    console.log(n);
}
//类
export class Num {}

更佳的写法是使用对象方式输出,整个模块导出什么一目了然.
//变量
var a = 1;
//方法
function log(n) {
    console.log(n);
}
//类
class Num {}

export {
    a,
    log,
    Num
}
这种写法也支持as关键字对外重命名如下
export {
    a as b,
    log as cng,
    Num as Digit
}

这里有一个隐藏比较深的概念性知识,export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。上面写法是OK的.
export var a = 1;
//或者
var a = 1;
export {
    a,
    //OR
    a as b,
}
但是你不能这么写,尽管看起来没什么问题,但是没有提供对外的接口,只是直接或者间接输出1.
export  1;
//或者
var a = 1;
export a
特别容易让人混淆的是这一句,所以要特别注意
//正确
export var a = 1;
//错误
var a = 1;
export a
这不仅仅是针对变量,包括方法和类也遵循这种写法,之所以会有这种要求是因为export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。
export var a = 1
setTimeout(() => a = 2, 3000);





##import 导入命令
import可以使用*做整体加载
import * as all from 'xx';
const {
    a,
    log,
    Num
} = all;

和expor相对应的按需引入写法如下
//直接引入写法
import{
    a,
    log,
    Num
}
//如果export时候使用as关键字则
import{
    b,
    cng,
    Digit
} from 'xx'
import也支持使用as关键字
import{
    b as a,
    cng as log,
    Digit as Num
} from 'xx'

和export动态绑定值不同,import是只读静态执行,即你不能修改引用的模块属性方法类等,也不能使用表达式和变量这种运行时才能引入静态分析阶段没法得到值的写法.
//修改属性
import{
    a
} from 'xx'
a = 2//error
//表达式引入
import{
    'l' + 'og'
} from 'xx'
//变量引入
var module = 'xx';
import{} from module
//判断引入
if (true) {
  import {} from 'xx1';
} else {
  import {} from 'xx2';
}
而且多次引用也只会执行一下,尽管不推荐,但是这种写法也是可以的
import{
    a
} from 'xx'
import{
    log
} from 'xx'
//=========
import{
    a,
    log
}

import也支持这种写法,仅仅执行lodash模块，但是不输入任何值。
import 'lodash';



//default关键字
export也支持default关键字默认导出写法:
1, 每个模块只支持一个default关键字默认导出;
2, 可以使用函数名或匿名函数导出,即使指定了函数名也不能在模块外部引用,等同视为匿名函数加载;
//方法
function log(n) {
    console.log(n);
}
export default log;
//OR
export default function(n) {
    console.log(n);
}
//OR
export default function log(n) {
    console.log(n);
}

import log from 'xx';
如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。
import log,{a,Digit as Num} from 'xx';

本质上这也只是一种语法糖,与下面写法等价
export default log;
import log from 'xx';
/==
export { log as default}
import { default as log } from 'xx';
因为default也是变量,所以不能后面再加变量
export default var a = 1;
但是可以直接输出了
export default 1;

注意关键字*会忽略default导入所有导出的变量.
import * from 'xx';


###export 与 import 的复合写法
这里提供了两种写法,他们之间会有些不同.
//引入后导出
import {log} from 'xx';
export {log};
//直接导出
export {log} from 'xx';
//或者
export {log as default} from 'xx';
区别在于第二三种是没有导入动作,所以不能在该模块引用对应的变量.

需要注意的是下面三种写法ES6目前还不支持复合写法.
export * as all from "xx";
export all from "xx";
export log,{a,Digit as Num} from 'xx';


###<script>使用


##Nodejs使用问题
import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行,而Nodejs的require是运行时加载模块,所以如果在Nodejs中使用ES6模块语法要注意这一点.
//成功
var fs = require('f'+'s');
//报错
import fs from ('f'+'s');

有一个提案，建议引入import()函数，完成动态加载,已经有实现方案了,我没用过就不说了.
