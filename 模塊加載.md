##原始時代
作爲一門語言的引入代碼方式，相較於其他如[bgcolor=#ec7379]PHP的include和require，Ruby的require，Python的import[/bgcolor]機制，Javascript是直接使用 &lt;script&gt; 標簽。
因为Javascript是一门单线程语言，GUI渲染线程和Javascript引擎线程是互斥的，代码执行 &lt;script&gt; 标签GUI渲染线程会挂起，然后下载资源，执行脚本，完成之后再继续往下执行。在那段时间内界面是不会响应用户操作的。用户体验相当不友好。同时还帶來一系列的隱患:

* 引入順序可能會引起代碼無效甚至報錯;
* 互不瞭解的代碼也許會造成重複命名覆蓋;
* 難以串聯代碼之間邏輯關係;
* 執行順序受影響的因素更多;
* 不易管理維護;

&lt;script&gt; 标签也提供了 [color=#f4511e]defer[/color] 和 [color=#f4511e]async[/color] 属性可以實現异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令，区别在于:
* defer: 等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行，可以保证顺序加载;
* async: 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染，不保证顺序加载;
```javascript
<script src="xx.js" defer></script>
<script src="xx.js" async></script>
```
出于需要社区制定了一些模块加载方案，最主要的有 [color=#ec7379]CommonJS[/color] 和 [color=#ec7379]AMD[/color] 两种。前者用于服务器，后者用于浏览器。




##CommonJS規範
CommonJS規範為Javascript制定的美好願景是希望Javascript能夠在任何地方運行，具備跨宿主環境執行的能力，例如:
* 富客戶端應用
* 服務器端Javascript應用程序（如Nodejs ）
* 命令行工具
* 桌面圖形界面應用程序
* 混合應用（Titanium和Adobe AIR等形式應用）


這些規範基本覆蓋了模塊，二進制，Buffer，字符集編碼，I/O流，進程環境，文件系統，套接字，單元測試，Web服務器網關接口，包管理等。



###模塊規範
1， 引用
模塊上下文提供 require() 方法引入外部模塊，一般如下
```javascript
var fs = require('fs');
```

---

2， 定義
模塊中存在一個上下文 module對象 ，它代表模塊自身， module對象 提供了 exports對象 用於導出當前模塊的变量、函数、类，并且是唯一的導出出口。
```javascript
//a.js模塊
exports.a = 1;
//引用a.js模塊
var a = require('a');
```

---

3， 標識
require() 方法接受小駝峰命名的字符串，或者相對/絕對路徑，并且可以省略文件後綴，它有自己一套匹配規則，後面再講。

* "./" 开头表示相對路径引用模块;
* "/" 开头表示绝对路径引用模块;
* 不帶上面符號開頭的小駝峰字符串表示默认提供的核心模块或者 [color=#ec7379]node_modules[/color] 下安裝模塊;
* 不帶上面符號開頭的路徑字符串表示 [color=#ec7379]node_modules[/color] 下安裝模塊對應后续路径;

```javascript
//a.js模塊
var a = require('./a');
var a = require('/a');
var a = require('a');
var a = require('a/a');
```

至此看來使用相當簡單，[bgcolor=#ec7379]模塊的意義在於將類聚的变量、函数、类等限定在私有作用域中，同時支持引入導出功能連接上下游依賴，避免了變量污染等問題[/bgcolor]。


###module.exports 和exports的關係?
exports 是引用 module.exports 的值，而真正導出的是 module.exports ，接著就是基本類型和引用類型的區別。
如果直接替換 module.exports 或者exports相當於切斷了和原有對象之間的關聯，後續兩者互不影響了。



##CommonJS加载原理
第一次 require() 一个脚本的时候会执行代碼然后在内存中会生成一个模块对象缓存起来，类似
```javascript
{
  id: '...',//模块的识别符，通常是带有绝对路径的模块文件名
  filename: '',//模块的文件名，带有绝对路径
  exports: {...},//导出变量、函数、类
  loaded: true,//模块是否已经完成加载
  parent: {},//调用该模块的模块
  children: [],//该模块要用到的其他模块
  ...
}
```

例如你創建一個文件腳本代碼執行就可以查看到這些信息。
```html:run
exports.a = 1;
console.log(module);
// Module {
//   id: '.',
//   exports: { a: 1 },
//   parent: null,
//
//   filename: 'C:\\project\\test\\module_demo\\test1.js',
//   loaded: false,
//   children: [],
//   paths:
//    [ 'C:\\project\\test\\module_demo\\node_modules',
//      'C:\\project\\test\\node_modules',
//      'C:\\project\\node_modules',
//      'C:\\node_modules' ] }
```


以后需要引用模块的变量、函数、类就在这个模块对象的 exports 取出，即使再次 require() 进来模块也不会重新执行，只会从缓存获取。


##CommonJS優點
* 模块引用順序決定加载顺序；
* 每個模块只会加载一次，然后將运行结果缓存起來二次利用，以后再次加载就直接读取缓存。要想让模块再次运行，必须清除缓存；
* 每個模塊都有其單獨的作用域，不会污染全局；



##Nodejs 模塊實現
Nodejs 借鋻了 CommonJS 但不完全按照規範實現了自己的模塊系統。

在Nodejs 引入模塊會經歷三個步驟:
* 路徑分析;
* 文件定位;
* 編譯執行;

在 Nodejs 中有兩種模塊
* Nodejs 提供的核心模塊;
    這部分模塊在 Nodejs 源代碼編譯過程中編譯進了二進制執行文件。在 Nodejs 進程啓動時部分核心模塊被直接加載進了内存中，所以在引用的時候可以省去文件定位和編譯執行的步驟，并且在路徑分析優先判斷，所以加載速度是最快的。

* 由用戶編寫的文件模塊;
    這部分模塊在運行時動態加載，需要經歷完整步驟。

Nodejs 會對引用過的模塊進行緩存以減少二次引入的開銷。而且緩存的是模塊編譯和執行之後的對象。所以 require() 對相同模塊的再次加載都是優先緩存方式，核心模塊的緩存檢查依然優先于文件模塊。


###Nodejs 模塊標識
前面提過的模塊標識，例如:
* 核心模塊fs等
    優先級僅次於緩存加載，如果直接引用自己編寫的和核心模塊具有相同標識的模塊會引用失敗，必須選擇不同標識符或者使用路徑方式加載。

* 路徑形式文件模塊
	分析過程中 rerquire() 會將路徑轉換成真實路徑，並以此為索引將編譯后結果緩存起來，因爲指明了模塊位置所以查找過程會省點時間，速度慢于核心模塊。

* 自定義模塊
    可能是以包或者文件形式的特殊模塊，查找費時速度最慢的一種，因爲他會用到模塊路徑的查找方法。


###模塊路徑規則
你可以隨便一個文件夾執行一個脚本如下看看打印信息，我是 Windows 系統結果如下
```javascript
console.log(module.paths);
// [ 'C:\\work\\project\\test\\node_modules',
//   'C:\\work\\project\\node_modules',
//   'C:\\work\\node_modules',
//   'C:\\node_modules' ]
```


從中可以看出他會從當前執行文件所在目錄下的 [color=#ec7379]node_modules[/color]，沿路徑向上逐層遞歸查找 [color=#ec7379]node_modules[/color] 直到根目錄爲止。
模塊加載過程會逐個嘗試直到符合條件或者沒有符合爲止，你可以看出裡面有著很明顯的問題。
* 層級越深查找起來越費時費力;
* 可能你衹想查看當前目錄，但是它失敗后會自動嘗試其他路徑;

這就是自定義模塊最慢的原因。


###文件定位
* 擴展名分析
    Nodejs 在標識符不包含後綴情況下會以[bgcolor=#ec7379].js， .json， .node[/bgcolor]的次序逐個嘗試匹配，而且過程中需要利用fs模塊以同步阻塞方式去判斷是否匹配，所以在非.js文件情況指明後綴能減少性能損耗的問題。

* 目錄分析和包
    還有一種情況是經過上面步驟之後都匹配不到對應文件但是有符合的目錄，此時Nodejs 會將其作爲一個包的方式處理。
    1）查找包下的 [color=#ec7379]package.json[/color] 文件（包描述文件），通過 [color=#ec7379]JSON.parse()[/color] 解析出文件讀取裏面的 [color=#ec7379]main[/color] 屬性定位對應的文件,省略後綴情況下需要執行擴展名分析步驟。
    2）如果沒有 package.json 或者 main 屬性不對，會用默認值 [color=#ec7379]index[/color] 去查找匹配文件，這一步需要擴展名分析步驟逐個嘗試。
    3）如果還是失敗就會根據模塊路徑規則往上層路徑尋找，直到全部路徑都沒有匹配文件就抛出失敗。


##模塊編譯
這是引入模塊的最後階段，定位到目標文件之後會新建一個模塊對象，然後根據路徑載入進行編譯，不同後綴文件載入方式不同:
* js通過fs模塊同步讀取文件之後編譯執行；
* node是C/C++編寫的擴展文件，通過 [color=#ec7379]dlopen()方法[/color] 加載最後編譯生成的對象；
* json通過fs模塊同步讀取文件之後用 JSON.parse() 解析返回結果；
* 其餘默認js處理方式；

每個編譯成功之後的模塊都會以其文件路徑作爲索引緩存在 [color=#ec7379]Module_cache[/color]。根據不同的擴展後綴 Nodejs 有不同的讀取方式。

1， Javascript模塊編譯
在編譯過程中，Nodejs 會對獲取的模塊進行包裝，如下:
```javascript
(function(exports, require, module, __filename, __dirname) {
    //模块源码
})
```


2， C/C++模塊編譯
Nodejs 調用 [color=#ec7379]process.dlopen()[/color] 方法進行加載執行，通過 [color=#ec7379]libuv封裝庫[/color] 支持 Windows 和 *nix 平臺下實現，因爲.node本身就是C/C++寫的，所以它不需要編譯，衹要加載執行就可以了，執行效率較高。

3， JSON文件編譯
上面説過通過fs模塊同步讀取文件之後用 JSON.parse() 解析返回結果，賦值給模塊對象的 exports。
除了配置文件，如果你開發中有需要用到json文件的時候可以不用 fs模塊 去讀取，而是直接 require() 引入更好，因爲能享受到緩存加載的便利。




##核心模塊
上面説過 Nodejs 模塊分爲核心模塊和文件模塊，剛才講的都是文件模塊的編譯過程，而 Nodejs 的核心模塊在編譯成可執行文件過程中會被編譯進二進制文件。核心模塊也分Javascript和C/C++編寫，前者在Node的[color=#ec7379]lib目錄[/color]，後者在Node的[color=#ec7379]src目錄[/color]。

###Javascript核心模塊編譯
1， 轉存為C/C++代碼
Nodejs 采用V8附帶的 [color=#ec7379]js2c.py工具[/color] 將内置的Javascript代碼[color=#ec7379]（src/node.js和lib/*.js）[/color]轉成C++的數組，生成 [color=#ec7379]node_natives.h[/color] 頭文件，Javascript代碼以字符串形式存儲在nodejs命名空間裏，此時還不能直接執行。等 Nodejs 啓動進程時候才被直接加載進内存中，所以不需要引入就能直接使用。

2， 編譯Javascript核心模塊
和文件模塊一樣也會被包裝成模塊對象，區別在於獲取源代碼的方式以及緩存執行結果的位置。
核心模塊源文件通過 [color=#ec7379]process.binding('natives')[/color] 取出，編譯完成後緩存到 [color=#ec7379]NativeModule._cache[/color] 對象上，而文件模塊會被緩存到 [color=#ec7379]Module._cache[/color]。


###C/C++核心模塊編譯（不懂C/C++，這一塊簡短略過）

1， 内建模塊的組織形式
每個内建模塊在定義之後會通過 [color=#ec7379]NODE_MODULE宏[/color] 將模塊定義到nodejs命名空間，模塊的具體初始化方法被挂載在結構的 [color=#ec7379]register_func[/color] 成員。
 [color=#ec7379]node_extensions.h[/color] 文件將散列的内建模塊統一放進 [color=#ec7379]node_module_list數組[/color] 中，Nodejs 提供了 [color=#ec7379]get_builtin_module()[/color] 方法從中取出。
[bgcolor=#ec7379]内建模塊優勢在於本身C/C++編寫性能優異，編譯成二進制文件時候被直接加載進内存，無需再做標識符定位，文件定位，編譯等過程。[/bgcolor]

2， 内建模塊導出
Nodejs 啓動會生成全局變量 [color=#ec7379]process[/color]，提供 [color=#ec7379]Binding()[/color] 方法協助加載内建模塊。
加載過程中我們會先生成 exports空對象 ，然後調用 [color=#ec7379]get_builtin_module()[/color] 方法去取内建模塊，通過執行 [color=#ec7379]register_func[/color] 填充空對象，最後按模塊名緩存起來並返回給調用方使用。

3， 核心模塊引入流程




##模塊調用
至此我們已經有個大概概念了，梳理一下各種模塊之間的關係：
* C/C++内建模塊是最底層核心模塊，主要提供API給Javascript核心模塊和第三方Javascript模塊使用；
* Javascript核心模塊分兩類，一類作爲C/C++内建模塊的封裝層和橋接層，一類純粹的功能模塊；
* 文件模塊分Javascript模塊和C/C++擴展模塊；



##ES6模块加载
直到ES6标准化模块功能，统一替代了之前多种模块实现库，成为浏览器和服务器通用的模块解决方案。ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量、函数、类。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。
ES6 的模块有几个需要注意的地方:
* 自动采用严格模式，即使你没有使用"use strict";
* 顶层的this指向undefined;

```javascript
// CommonJS模块
let {readFile} = require('fs');
// ES6模块
import {readFile} from 'fs';
```

以上为例。
CommonJS加载整个 fs模块 生成一个模块对象，然后从对象中导出 readFile方法 。
ES6 模块通过 import命令 从 fs模块 加载输入的变量、函数、类。
结果就是ES6模块效率高，但是拿不到模块对象本身。
|加载方案|加载|输出|
| :--- | :---: | ---: |
|CommonJS|运行时加载|拷贝|
|ES6 模块|编译时输出接口|引用|

由于 ES6 模块是编译时加载，使得静态分析成为可能。比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。

ES6 模块还有以下好处:
* 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。
* 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator对象 的属性。
* 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。
* ES6模块提供了 export导出命令 和 import导入命令 ，它们同样具有全局提升的效果，只要在顶层使用即可。


###export导出命令
支持输出变量、函数、类。
```javascript
//变量
export var a = 1;
//函数
export function log(n) {
    console.log(n);
}
//类
export class Num {}
```


我習慣写法是使用对象方式输出，整个模块导出什么一目了然。
```javascript
//变量
var a = 1;
//函数
function log(n) {
    console.log(n);
}
//类
class Num {}

export {
    a,
    log,
    Num
}
```

这种写法也支持as关键字对外重命名
```javascript
export {
    a as b,
    log as cng,
    Num as Digit
}
```


这里有一个隐藏比较深的概念性知识，[bgcolor=#ec7379]export命令规定的是对外的接口必须与模块内部的变量、函数、类建立一一对应关系[/bgcolor]。這種写法是OK的。
```javascript
export var a = 1;
//或者
var a = 1;
export {
    a,
    //或者
    a as b,
}
```

但是你不能这么写，尽管看起来没什么问题，不過没有提供对外的接口，只是直接或者间接输出1。
```javascript
export  1;
//或者
var a = 1;
export a
```

特别容易让人混淆的是这一句，所以要特别注意
```javascript
//正确
export var a = 1;
//错误
var a = 1;
export a
```

这不仅仅是针对变量，包括函数和类也遵循这种写法，之所以会有这种要求是因为 [bgcolor=#ec7379]export语句 输出的接口，与其对应的值是动态绑定关系[/bgcolor]，即通过该接口，可以取到模块内部实时的值。
```javascript
export var a = 1
setTimeout(() => a = 2, 3000);
//後續引用a會得到2
```






##import 导入命令
和expor相对应的按需引入写法如下
```javascript
//直接引入写法
import{
    a,
    log,
    Num
} from 'xx'
```

import也支持使用as关键字
```javascript
import{
    a as b,
    log as cng,
    Num as Digit
} from 'xx'
```


和 export 动态绑定值不同，[bgcolor=#ec7379]import 是只读静态执行，即你不能修改引用的模块变量、函数、类等，也不能使用表达式和变量这种运行时才能引入静态分析阶段没法得到值的写法[/bgcolor]。
```javascript
//修改属性
import{a} from 'xx'
a = 2//error
```
```javascript
//表达式引入
import{'l' + 'og'} from 'xx'
//变量引入
var module = 'xx';
import {} from module//error
```

```javascript
//判断引入
//error
if (true) {
  import {} from 'xx1';
} else {
  import {} from 'xx2';
}
```


因為多次引用也只会执行一次，尽管不推荐，但是这种写法也是可以的
```javascript
import{a} from 'xx'
import{log} from 'xx'
//等價于
import{
    a,
    log
} from 'xx'
```


import也支持这种写法，仅仅执行模块，但是不输入任何变量、函数、类。
```javascript
import 'xx';
```




###关键字default
export 支持 [color=#ec7379]关键字default[/color] 設置默认导出的变量、函数、类:
1， 每个模块只支持一个关键字default默认导出;
2， 可以使用函数名或匿名函数导出，即使指定了函数名也不能在模块外部引用，等同视为匿名函数加载;
```javascript
//函数
function log(n) {
    console.log(n);
}
export default log;
//或者
export default function(n) {
    console.log(n);
}
//或者
export default function log(n) {
    console.log(n);
}
```

其他模块加载该模块时，import命令可以为该默认导出函数指定任意名字。
```javascript
export default function log(n) {
    console.log(n);
}
//加载
import anyName from 'xx';
```



如果想在一条 import语句 中，同时输入默认函数和其他接口，可以写成下面这样。
```javascript
import log, {a, Num as Digit} from 'xx';
```


本质上这也只是一种语法糖，与下面写法等价
```javascript
export default log;
import log from 'xx';
//==等价==
export { log as default}
import { default as log } from 'xx';
```

因为default也是变量，所以不能后面再加变量
```javascript
export default var a = 1;
```

但是可以直接输出
```javascript
export default 1;
export default a;
```





###关键字*
用星号（*）指定一个对象，所有输出值都加载在这个对象上面。
```javascript
import * as all from 'xx';
const {
    a,
    log,
    Num
} = all;
```



###export 与 import 的复合写法
这里提供了两种写法，他们之间会有些不同。
```javascript
//引入后导出
import {log} from 'xx';
export {log};
//直接导出
export {log} from 'xx';
//或者
export {log as default} from 'xx';
```

区别在于第二三种是没有导入动作，所以不能在该模块引用对应的变量、函数、类。

需要注意的是下面三种写法ES6目前还不支持。
```javascript
export * as all from "xx";
export all from "xx";
export log, {a, Digit as Num} from 'xx';
```



##Nodejs 使用问题
import命令 会被 JavaScript引擎 静态分析，先于模块内的其他语句执行，而 Nodejs 的 require() 是运行时加载模块，import命令无法取代require的动态加载功能,所以如果在Nodejs 中使用ES6模块语法要注意这一点。
```javascript
//成功
var fs = require('f'+'s');
//报错
import fs from ('f'+'s');
```


有一个提案，建议引入 import() 函数，完成动态加载，已经有实现方案了，我没用过就不说了。



##参考资料
