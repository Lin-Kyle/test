##原始時代
作爲一門語言的引入代碼方式,相較於其他如PHP的include和require,Ruby的require,Python的import機制,Javascript是直接使用<script>標簽,這就會帶來一系列的隱患:
1, 引入順序可能會引起代碼無效甚至報錯;
2, 互不瞭解的代碼也許會造成重複命名覆蓋;
3, 難以串聯代碼之間邏輯關係;
4, 執行順序受影響的因素更多;
5, 不易管理;

##CommonJS規範
CommonJS規範為Javascript制定的美好願景是希望Javascript能夠在任何地方運行,具備跨宿主環境執行的能力,例如:
* 富客戶端應用
*  服務器端Javascript應用程序(如Nodejs)
* 命令行工具
* 桌面圖形界面應用程序
* 混合應用(Titanium和Adobe AIR等形式應用)
這些規範基本覆蓋了模塊,二進制,Buffer,字符集編碼,I/O流,進程環境,文件系統,套接字,單元測試,Web服務器網關接口,包管理等.

###模塊規範
1, 引用
模塊中上下文提供require方法引入外部模塊,Nodejs引入文件一般如下
var fs = require('fs');

2, 定義
模塊中存在一個上下文module對象,他代表模塊自身,module提供了exports對象用於導出當前模塊的方法變量,并且是唯一的導出出口
//a.js模塊
exports.a = 1;
//引用a.js模塊
var a = require('a');

3, 標識
require()方法接受小駝峰命名的字符串,或者相對/絕對路徑,并且可以省略文件後綴,有自己一套匹配規則後面再講.
至此看來使用相當簡單,模塊的意義在於將類聚的方法變量等限定在私有作用域中,同時支持引入導出功能鏈接上下游依賴,避免了變量污染等問題.

module.exports和exports的關係?
exports是引用module.exports的值,而真正導出的module.exports,接著就是基本類型和引用類型的區別了.
如果直接替換module.exports或者exports相當於切斷了和原有對象之間的關聯,後續兩者互不影響了.



Nodejs模塊實現
Nodejs借鋻了CommonJS但不完全按照規範實現了自己的模塊系統.在Nodejs中有兩種模塊
* Nodejs提供的核心模塊;
    這部分模塊在Nodejs源代碼編譯過程中編譯進了二進制執行文件.在Nodejs進程啓動時部分核心模塊被直接加載進了内存中,所以在引用的時候可以省去文件定位和編譯執行的步驟,并且在路徑分析優先判斷,所以加載速度是最快的.

* 由用戶編寫的文件模塊;
    這部分模塊在運行時動態加載,需要經歷完整步驟.

在Nodejs引入模塊會經歷三個步驟:
1, 路徑分析;
2, 文件定位;
3, 編譯執行;
Nodejs會對引用過的模塊進行緩存以減少二次引入的開銷.而且緩存的是模塊編譯和執行之後的對象.所以require對相同模塊的二次加載都是優先緩存方式,核心模塊的緩存檢查依然優先文件模塊.

###路徑分析
前面提過的模塊標識,例如:
* 核心模塊fs等
    優先級僅次於緩存加載,如果有引用自己編寫的相同標識模塊會失敗,必須選擇不同標識符或者使用路徑方式加載.

* 路徑形式文件模塊
分析過程中rerquire()會將路徑轉換成真實路徑,並以此為索引將編譯后結果緩存起來,因爲指明了模塊位置所以查找過程會省點時間,速度慢于核心模塊.

* 自定義模塊
    可能是以包還活著文件形式的特殊模塊,查找費時速度最慢的一種.因爲他會用到模塊路徑的查找方法.


###模塊路徑規則
你可以隨便一個文件夾執行一個脚本如下看看打印信息,我是Windows系統結果如下
console.log(module.paths);
[ 'C:\\work\\project\\test\\node_modules',
  'C:\\work\\project\\node_modules',
  'C:\\work\\node_modules',
  'C:\\node_modules' ]

從中可以看出他會從當前執行文件所在目錄下的node_modules,沿路徑向上逐層遞歸查找node_modules知道根目錄爲止.
模塊加載過程會逐個嘗試直到符合條件或者沒有符合爲止.
1, 層級越深查找起來越費時費力;
2, 可能你衹想查看當前目錄,但是它失敗后會自動嘗試其他路徑;
這就是自定義模塊最慢的原因.

###文件定位
* 擴展名分析
    Nodejs在標識符不包含後綴情況下會以.js, .json, .node的次序逐個嘗試匹配,而且過程中需要利用fs模塊以同步阻塞方式去判斷是否匹配,所以在非.js文件情況指明後綴會減少性能問題.

* 目錄分析和包
    還有一種情況是經過上面步驟之後都匹配不到對應文件但是有符合的目錄,此時Nodejs會將其作爲一個包的方式處理.
    1), 查找包下的package.json文件(包描述文件),通過JSON.parse()解析出文件讀取裏面的main屬性定位對應的文件.可能需要擴展名分析步驟.
    2) 如果沒有package.json或者main屬性不對,用默認值index去查找匹配文件,這一步需要擴展名分析步驟逐個嘗試.
    3) 如果還是失敗就會根據模塊路徑規則往上層路徑尋找.直到全部路徑都沒有匹配文件就抛出失敗.


##模塊編譯
這是引入模塊的最後階段,定位到目標文件之後會新建一個模塊對象,然後根據路徑載入進行編譯,不同後綴文件載入方式不同:
* js通過fs模塊同步讀取文件之後編譯執行
* node是C/C++編寫的擴展文件,通過dlopen()方法加載最後編譯生成的對象
* json通過fs模塊同步讀取文件之後用JSON.parse()解析返回結果
* 其餘默認js處理方式

每個編譯成功之後的模塊都會以其文件路徑作爲索引緩存在Module_cache.根據不同的擴展後綴Nodejs有不同的讀取方式.

1, Javascript模塊編譯
在編譯過程中,Nodejs會對獲取的模塊進行包裝,如下:
(function(exports, require, module, __filename, __dirname) {
    //模块源码
})

每個模塊都有各自獨立的作用域,exports上的所有方法屬性都能被外部使用

2, C/C++模塊編譯
Nodejs調用process.dlopen()方法進行加載執行,通過libuv封裝庫支持Windows和*nix平臺下實現,因爲.node本身就是C/C++寫的,所以它不需要編譯,衹要加載執行就可以了,所以執行效率較高.

3, JSON文件編譯
上面説過通過fs模塊同步讀取文件之後用JSON.parse()解析返回結果,賦值給模塊對象的exports.
除了配置文件,如果你開發中有需要用到json文件的時候可以不用fs模塊去讀取,而是直接require()引入更好,因爲能享受到緩存加載的便利.




##核心模塊
上面説過Nodejs模塊分爲核心模塊和文件模塊,剛才講的都是文件模塊的編譯過程,而Nodejs的核心模塊在編譯成可執行文件過程中會被編譯進二進制文件.核心模塊也分Javascript和C/C++編寫,前者在Node的lib目錄,後者在Node的src目錄.

###Javascript核心模塊編譯
1, 轉存為C/C++代碼
Nodejs采用V8附帶的js2c.py工具將内置的Javascript代碼(src/node.js和lib/*.js)轉成C++的數組,生成node_natives.h頭文件,Javascript代碼以字符串形式存儲在nodejs命名空間裏,此時還不能直接執行.
儅Nodejs啓動進程時候才被直接加載進内存中.所以不需要引入就能直接使用.

2, 編譯Javascript核心模塊
和文件模塊一樣也會被包裝成模塊對象,區別在於獲取源代碼的方式以及緩存執行結果的位置.
核心模塊源文件通過process.binding('natives')取出,編譯完成後緩存到NativeModule._cache對象上,文件模塊被緩存到Module._cache


###C/C++核心模塊編譯(不懂C/C++,這一塊簡短略過)
1, 内建模塊的組織形式
每個内建模塊在定義之後會通過NODE_MODULE宏將模塊定義到nodejs命名空間,模塊的具體初始化方法被挂載在結構的register_func成員.
node_extensions.h文件將散列的内建模塊統一放進node_module_list數組中,Nodejs提供了get_builtin_module()方法從中取出.
内建模塊優勢在於本身C/C++編寫性能優異,編譯成二進制文件時候被直接加載進内存,無需在做標識符定位,文件定位,編譯等過程.

2, 内建模塊導出
Nodejs啓動會生成全局變量process,提供Binding()方法協助加載内建模塊.
加載過程中我們會先生成exports空對象,然後調用get_builtin_module()方法去除内建模塊,通過執行register_func填充空對象,最後按模塊名緩存起來並返回給調用方使用.

3, 核心模塊引入流程




##模塊調用
至此我們已經有個大概概念了,梳理一下各種模塊之間的關係
C/C++内建模塊是最底層核心模塊主要提供API給Javascript核心模塊和第三方Javascript模塊使用.
Javascript核心模塊分兩類,一種作爲C/C++内建模塊的封裝層和橋接層,一類純粹的功能模塊.
文件模塊分Javascript模塊和C/C++擴展模塊.
