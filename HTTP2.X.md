# 前言
这篇文章实话说我有点虚，因为平时都不怎么研究这一块的，然后涉及到的知识点超多，我只能到处看看资料总结一下相关信息，所以在此我只想说句：
**本文章内容只代表个人立场，有错必改！**
原本打算一次性总结，后来越扯越多超过字数限制了，就干脆做成http系列文章了，不定时更新原有内容（发现哪里出错的话），不定时新增系列文章，请见谅!

因为之前写得太臃肿又不够详细，最近刚好复习到这一块的内容，所以决定把这些文章都拆分成更加细致一点，补充详细内容，优化排版布局，目前来看还是应该的，因为自身时间问题和平台编译的问题迟迟未改，只好等都改完之后才发出来。
[网络协议基础 — TCP、UDP与参考模型](https://www.qdfuns.com/article/40831/f14ba529d04202c7c10604eb3a2b5e56.html)
[Http协议系列 — 协议原理构成与连接管理](https://www.qdfuns.com/article/40831/577fa2647a7eb3123c6b138c6299c640.html)
[Http协议系列 — cookie，Session，缓存机制](https://www.qdfuns.com/article/40831/8fbe235d81b5ada00b53ddde9fd848a4.html)
[Http协议系列—-进阶Https基础](https://www.qdfuns.com/article/40831/3ffb59e3d1dfc7ed44e521c2a57aeec7.html)
[WebSocket协议入门基础](https://www.qdfuns.com/article/40831/6db7957dad157aa4239ec144c0aa9c55.html)
[简单使用Nodejs+Socket.io2.0+boostrap4.0实现聊天室功能](https://www.qdfuns.com/article/40831/18843630b0a73d009fe9ed56e70156a8.html)

## HTTP1.x缺点?
1，HTTP 协议是没有状态，导致每次请求都必须附上所有信息;
2，两个报文之间的 [color=#2b91e3]**header**[/color] 通常非常相似，但它们仍然在连接中重复传输且没有经过压缩;
3，[color=#b1b1b1]（HTTP/1.0）[/color]每次请求都需要重新建立连接，可以添加头**[color=#2b91e3]Connection: keep-alive[/color]**建立持久连接；
4，即使复用持久连接也是同步次序方式进行的，即服务器要处理完上一个才会进行下一个；
5，浏览器对同一域名下同时开启持久连接数限制大概在五个左右；

## HTTP2改进?
### 传输协议
HTTP1.x是以纯文本的形式进行通信的，HTTP2彻底使用[color=#2b91e3]**二进制协议**[/color]替换，头信息和数据体都是二进制，并且统称为[color=#2b91e3]**帧**[/color]：常见的帧例如传输头信息的Header帧、传输正文内容的Data帧。因为二进制协议解析起来更高效错误更少。


### 头信息
HTTP2使用HPACK算法对头部进行压缩，基本原理：[color=#f4511e]客户端和服务端分别缓存一份索引表，如果头部存在于索引表，则用对应的索引值；否则进行霍夫曼编码，并加入索引表[/color]，简单来说既避免了重复header的传输，又减小了需要传输数据的大小


### 传输
HTTP2会将一个TCP连接切分成多个流，每个流都有自己的ID，流是有优先级的虚拟通道，可以是服务器和客户端互相发送。
HTTP2将所有传输信息分割成更小的信息和帧，并对它们采用二进制格式编码。
HTTP2可以将多个请求分到不同的流中然后将请求内容拆分成帧进行二进制传输，这些帧可以打散乱序发送然后根据每个帧首部的流标识符重新组装，并且可以根据优先级决定处理流数据的顺序。


### 服务器推送
HTTP2允许服务器未经请求主动向客户端发送资源，通过一个叫服务器推送的机制来提前请求。
通过推送那些服务器任务客户端将会需要的内容到客户端的缓存中，避免往返的延迟。


### 例子
假设有一个简单的页面，他首屏只有三个请求，业务逻辑js，样式美化css，图片png。
HTTP1.x是串行请求的
![图片描述](attimg://article/content/picture/201808/15/152429z94mzo5hbx4r48rg.png)
[color=#b1b1b1]（我知道我画的好丑，但是将就着看吧）[/color]

HTTP2是多路复用，可以同时发送，请求和应答可以不按顺序一一对应。
![图片描述](attimg://article/content/picture/201808/15/152430qaof4dm4xaabb7ae.png)
[color=#b1b1b1]（我知道我画的好丑，但是将就着看吧）[/color]

HTTP2其实就是将三个请求换成三个流然后数据换成帧乱序发到同一个TCP连接中。这样既避免了串行堵塞的问题，还能减少连接数和前置操作，加快前端获取资源速度。

### 优点
HTTP2 帧机制是在 HTTP/1.x 语法和底层传输协议之间增加了一个新的中间层，而没有从根本上修改它，即它是建立在经过验证的机制之上。Web 开发人员不需要在其使用的 API 中做任何更改来利用 HTTP 帧；当浏览器和服务器都可用时，HTTP2 将被打开并使用。

### 缺点
尽管看起来HTTP2大大改善请求的局限性，但是也逃脱不了是基于TCP协议的命运，TCP在处理包的时候是严格控制顺序的。
如果其中一个数据包出错，TCP需要等它重新发送过来才能继续进行后续操作，虽然HTTP2通过优化处理机制实现并行内容多路传输，然而中间并没有关联的数据。
Google的QUIC协议就很好改善这问题了，我不熟悉就不说了。





## 特殊字符编码
在使用**[color=#2b91e3]URL[/color]**进行参数传递时，经常会传递一些中文名的参数或URL地址，在后台处理时会发生转换错误。例如:
在有些传递页面使用**[color=#2b91e3]GB2312[/color]**，而在接收页面使用**[color=#2b91e3]UTF8[/color]**，这样接收到的参数就可能会与原来发生不一致。
使用服务器端的urlEncode函数编码的URL，与使用客户端javascript的encodeURI函数编码的URL，结果就不一样。

在请求参数中有些字段是不能直接传输的，可能会引起问题，于是我们需要在发送前先进行编码。

|方法|用法|返回值|说明|
|-|-|
| escape（string）|可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。|已编码的 string 的副本。其中某些字符被替换成了十六进制的转义序列。| 该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码：* @ - _ + . / 。其他所有的字符都会被转义序列替换。|
| unescape（string）|可对通过 escape（）编码的字符串进行解码。|string 被解码后的一个副本。| 通过找到形式为 %xx 和 %uxxxx 的字符序列（x 表示十六进制的数字），用 Unicode 字符 \u00xx 和 \uxxxx 替换这样的字符序列进行解码。|
| encodeURI（URIstring）| 把字符串作为 URI 进行编码。| URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换。| 该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：- _ . ! ~ * ' ( ) 。该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&=+$,#|
|decodeURI（URIstring）| 对 encodeURI（）函数编码过的 URI 进行解码。|URIstring 的副本，其中的十六进制转义序列将被它们表示的字符替换。| |
| encodeURIComponent（URIstring）| 把字符串作为 URI 组件进行编码。|URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换。|该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：- _ . ! ~ * ' ( ) 。其他字符（比如 ：;/?:@&=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。|
|decodeURIComponent（URIstring）| 对 encodeURIComponent（）函数编码的 URI 进行解码。|URIstring 的副本，其中的十六进制转义序列将被它们表示的字符替换。| |


* escape（）除了 ASCII 字母、数字和特定的符号外，其他所有的字符都会被转义序列替换[color=#b1b1b1]（已被废弃使用）[/color]。
* encodeURI（）除了 ASCII 字母、数字和特定的符号外，[color=#f4511e]对 URI 进行完整的编码，并且URI中的合法字符都不会被编码转换[/color]。
* encodeURIComponent（）除了 ASCII 字母、数字和特定的符号外，其他字符都是由一个或多个十六进制的转义序列替换的。

**注意**:
1，上面指明的[color=#f4511e]特定符号[/color]每个方法都各不相同;
2，encodeURIComponent（）函数 与 encodeURI（）函数的区别之处在于[color=#f4511e]前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）[/color]。因此 [color=#f4511e]encodeURIComponent（）函数将转义用于分隔 URI 各个部分的标点符号[/color]。
> escape('https://www.baidu.com/index.html?abc=1&name=特殊字符编码')
"https%3A//www.baidu.com/index.html%3Fabc%3D1%26name%3D%u7279%u6B8A%u5B57%u7B26%u7F16%u7801"

> encodeURI('https://www.baidu.com/index.html?abc=1&name=特殊字符编码')
"https://www.baidu.com/index.html?abc=1&name=%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81";

> encodeURIComponent('https://www.baidu.com/index.html?abc=1&name=特殊字符编码')
"https%3A%2F%2Fwww.baidu.com%2Findex.html%3Fabc%3D1%26name%3D%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"



## 疑难杂症
### HTTP控制的常见特性?
1，缓存
服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档;

2，开放同源限制
为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于相同来源的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的[color=#b1b1b1]（某些情况下，这样做还有安全因素考虑）[/color];

3，认证
一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用Authenticate相似的头部即可，或用HTTP Cookies来设置指定的会话;

4，代理和隧道
通常情况下，服务器（和|或）客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理;

5，会话
使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话;


### 什么是代理?
代理是位于客户端和服务器之间的HTTP中间实体。接收所有客户端的HTTP请求，并将这些请求转发给服务器[color=#b1b1b1]（可能会对请求进行修改之后转发）[/color]。



### 代理（Proxies）作用?
1）缓存[color=#b1b1b1]（可以是公开的也可以是私有的，像浏览器的缓存）[/color];
2）过滤[color=#b1b1b1]（像反病毒扫描，家长控制。。。）[/color];
3）负载均衡[color=#b1b1b1]（让多个服务器服务不同的请求）[/color];
4）认证[color=#b1b1b1]（对不同资源进行权限管理）[/color];
5）日志记录[color=#b1b1b1]（允许存储历史信息）[/color];


### 什么是网关？
网关是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将HTTP流量转换成其他的协议。


### 什么是隧道？
隧道是建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。常见用途是通过HTTP连接承载加密的安全套接字层[color=#2b91e3]（SSL）[/color]流量，这样SSL流量就可以穿过只允许Web流量通过的防火墙了。


### 什么是Agent代理？
用户Agent代理是代表用户发起HTTP的客户端程序。比如Web浏览器。另外有些自动发送HTTP请求并获取内容的代理，比如“网络蜘蛛”或者“Web机器人”。


### 可以禁止浏览器缓存的方法?
1）Expires设置0;
2）Cache-Control: no-cache;
3）Pragma: no-cache;



### 关于Cache-Control中no-cache、no-store、max-age=0区别?
1）no-cache代表不缓存过期的资源，缓存会向服务器进行有效处理确认之后处理资源;
2）no-store才是真正的不进行缓存;
3）max-age=<0就请求服务器，如果资源修改了服务器就会返回最新资源，如果资源没修改服务器就只返回304（Not Modified）状态码;



### 什么是CDN?
CDN的全称是[color=#2b91e3]Content Delivery Network[/color]，即内容分发网络。其基本思路是[color=#f4511e]尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定[/color]。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。

1，本地Cache加速: 提高了企业站点[color=#b1b1b1]（尤其含有大量图片和静态页面站点）[/color]的访问速度，并大大提高以上性质站点的稳定性
2，镜像服务: 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。
3，远程加速: 远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度
4，带宽优化: 自动生成服务器的远程[color=#2b91e3]Mirror（镜像）cache服务器[/color]，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。
5，集群抗攻击: 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种[color=#2b91e3]DDOS[/color]攻击对网站的影响，同时保证较好的服务质量 。



### 缓存服务器作用?
加速资源访问速度，降低源服务器的负载。缓存服务器从源服务器获取资源，并返回给浏览器。此外，缓存服务器一般还会在本地保存资源的副本，当有相同的资源请求到来，缓存服务器可返回资源副本，以此提高资源访问速度。



### 使用cookie保存登陆信息的方法?
1）Cookie保存用户名与密码，与数据库比较;
2）Cookie保存加密后的密码，访问时解密与数据库比较;
3）Cookie保存用户名与加密后的用户名，与数据库比较账号的加密规则是否正确;
