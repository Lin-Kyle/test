#前言
終於開始我nodejs的博客生涯了,先從基本的原理講起.

##什麽是nodejs?
用官網的説法就是:
Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。
Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。
Node.js 的包管理器 npm，是全球最大的开源库生态系统。
一三我就跳過不講了,那是外部條件因素,我們集中精力瞭解第二條.


##什麽是非阻塞式 I/O?
爲了更加全面講解這個點,我們可以把I/O都列出來,分別是:
当进程调用一个进行I/O操作的API請求时（例如讀寫操作）
* 阻塞I/O(blocking I/O): 在結果沒有返回之前會阻塞著進程/线程執行其他操作,直到得到結果爲止才結束阻塞狀態;

* 非阻塞I/O(non-blocking I/O): 不等待結果就立即返回讓進程/线程繼續執行其他操作,想要知道請求結果完成的方法
1) 輪詢;
2) I/O多路復用;

>摘抄自<<深入淺出nodejs>>
操作系統對計算機進行了抽象,將所有輸入輸出設備抽象為文件.内核在進行文件I/O操作時,通過文件描述符進行管理,而文件描述符類似於應用程序與系統内核之間的憑證.應用程序如果需要進行I/O調用,需要先打開文件描述符,然後再根據文件描述符去實現文件的數據讀寫.此處[color=#ff4753]非阻塞I/O與阻塞I/O的區別在於阻塞I/O完成整個獲取數據的過程,而非阻塞I/O則不帶數據直接返回,要獲取數據,還需要通過文件描述符再次讀取.[/color]

当進程/线程发起I/O操作之后:
* 同步I/O(synchronous I/O): 将process阻塞等待I/O操作的完成或数据的返回。按照这个定义，之前所述的阻塞I/O，非阻塞I/O，I/O多路復用都属于同步I/O。

* 异步I/O(synchronous I/O): 直接返回继续执行下一条语句，当操作系统完成IO操作时，以事件的形式通知执行IO操作的進程/线程.

例如有兩段I/O代碼執行分別需時a和b:
同步執行需時: a+b;
異步執行需時: Math.max(a,b);
這就是爲什麽異步I/O是nodejs的主要理念,因爲I/O代價非常昂貴.

簡單總結:
**阻塞I/O和非阻塞I/O区别在于：调用后是否立即返回！**
**同步I/O和异步I/O区别在于：會不會将process阻塞！**

用個生活化的例子就是等外賣吧
阻塞I/O: 白領A下完單就守著前臺小姐直到收到外賣才離開,後面其他人在排隊等他走開;
非阻塞I/O: 白領B下完單每隔一段時間就去詢問前臺小姐外賣到了沒,然後回去上班,需要來回走多次;
异步I/O: 白領C下完單就不管,知道前臺小姐告訴他外賣到了;


##nodejs的異步I/O實現
四個共同構成Node異步I/O模型的基本要素:

###事件循環
進程啓動之後node就會創建一個循環,每執行一次循環體的過程成爲Tick.每個Tick的過程就是看是否有事件待處理,有就取出事件及其相關回調執行,然後再重複Tick,否則退出進程.

###觀察者
每個事件循環中有一個或多個的觀察者,通過詢問這些觀察者就能得知是否有事件需要進行處理.
瀏覽器中的事件可能來源於界面的交互或者文件加載而產生,而Node主要來源於網絡請求,文件I/O等,這些產生的事件都有對應的觀察者

###請求對象
對於Node中異步I/O調用,從發起調用到内核執行完I/O操作的過渡過程中存在一種中間產物請求對象.
在Javascript層面代碼會調用C++核心模塊,核心模塊會調用内建模塊通過libuv進行系統調用.創建一個請求對象并將入參和當前方法等所有狀態都封裝在請求對象,包括送入綫程池等待執行以及I/O操作完畢之後的回調處理.然後被推入綫程池等待執行,Javascript調用至此返回繼續執行當前任務的後續操作,第一階段完成.


###執行回調
綫程池中的I/O操作調用完成之後會保存結果然後向IOCP提交執行狀態告知當前對象操作完成并將綫程歸還綫程池.中間還動用到事件循環的觀察者,每次Tick都會檢查綫程池是否有執行完的請求,有就將請求對象加入到I/O觀察者的隊列中當作事件處理.至此整個異步I/O流程結束.



##非I/O異步API
###定時器




##事件驱动
算是一种通过监听事件或状态的变化而执行回调函数的流程控制方法,一般步骤
1、确定响应事件的元素;
2、为指定元素确定需要响应的事件类型;
3、为指定元素的指定事件编写相应的事件处理程序;
4、将事件处理程序绑定到指定元素的指定事件;

###process.nextTick(callback) 字面意思就知道这个函数定义一个动作让其在下一个Tick中执行.但是不同于上面的定时器.在内部的处理机制不同,nextTick拥有比延时更多的特性.
