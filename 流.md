## 流（stream）
流（stream）是一种可读写的在 Node.js 中处理流式数据的抽象接口，所有的流都是 EventEmitter 的实例。
 stream 模块提供了一些基础的 API，用于构建实现了流接口的对象，尽管理解流的工作方式很重要，但是 stream 模块本身主要用于开发者创建新类型的流实例。 对于以消费流对象为主的开发者，极少需要直接使用 stream 模块。

 ## 流的类型
* Writable - 可写入数据的流（例如 fs.createWriteStream()）。
* Readable - 可读取数据的流（例如 fs.createReadStream()）。
* Duplex - 可读又可写的流（例如 net.Socket）。
* Transform - 在读写过程中可以修改或转换数据的 Duplex 流（例如 zlib.createDeflate()）。

## 可写流（stream.Writable 类）
可写流是对数据要被写入的目的地的一种抽象，所有可写流都实现了 stream.Writable 类定义的接口。

我们先以 fs模块 的 fs.WriteStream 类 为例运行一次看看效果，然后再针对stream.Writable 类的方法事件做进一步详解。
* close：当 WriteStream 底层的文件描述符被关闭时触发。
* open：当 WriteStream 的文件被打开时触发。
* ready：当 fs.WriteStream 已准备好被使用时触发，在 'open' 事件之后立即触发。
* finish：当 fs.WriteStream 写入完成时触发。
* error：当 fs.WriteStream 错误时触发。

```
const fs = require('fs');

//没有就自动生成文件
const path = './lesson1.txt',
    options = {},
    writable = fs.createWriteStream(path, options);

//监听事件
writable.on('open', () => console.log('open'))
writable.on('ready', () => console.log('ready'))
writable.on('finish', () => console.log('finish'))
writable.on('close', () => console.log('close'))
writable.on('error', () => console.log('error'))

//写完结束
writable.write('我就随便写点什么吧！');
writable.write('你就随便看看吧！');
writable.end();
//open
//ready
//finish
//close
```
LS1

### stream.Writable 类事件
* 'close' 事件
    - 当流或其底层资源（比如文件描述符）被关闭时，触发 'close' 事件。 该事件表明不会再触发其他事件，且不会再发生运算。
    - 不是所有可写流都会触发 'close' 事件。

* 'drain' 事件
    - 如果调用 stream.write(chunk) 方法返回 false，则在适合恢复写入数据到流时触发 'drain' 事件。

* 'error' 事件
    - 当写入数据出错或使用管道出错时，触发 'error' 事件。 监听器回调函数被调用时会传入一个 Error 参数。
    - 但触发 'error' 事件时，流还未被关闭。

* 'finish' 事件
    - 调用 stream.end() 方法且缓冲数据都已经传给底层系统之后，触发 'finish' 事件。

* 'pipe' 事件
    - 当在可读流上调用 stream.pipe() 方法添加可写流到目标流向时，触发 'pipe' 事件。

* 'unpipe' 事件
    - 当在可读流上调用 stream.unpipe() 方法从目标流向中移除当前可写流时，触发 'unpipe' 事件。
    - 当可读流通过管道流向可写流发生错误时，也会触发 'unpipe' 事件。

* 'finish' 事件
    - 调用 stream.end() 方法且缓冲数据都已经传给底层系统之后，触发 'finish' 事件。

* 'finish' 事件
    - 调用 stream.end() 方法且缓冲数据都已经传给底层系统之后，触发 'finish' 事件。


### stream.Writable 类方法
*writable.write(chunk[, encoding][, callback])*

|    参数 | 描述    |
| --- | --- |
|  chunk（string，Buffer，Uint8Array，any）   |  要写入的数据。可选的。 对于非对象模式下的流， chunk 必须是字符串， Buffer 或者 Uint8Array。对于对象模式下的流，chunk 可以是除 null 外的任意 JavaScript 值。 |
|  encoding（string）  |  如果 chunk 是字符串，这里指定字符编码。 |
|  callback（Function） |  缓冲数据输出时的回调函数  |

writable.write() 方法向流中写入数据，并在数据处理完成后调用 callback 。如果有错误发生， callback 不一定 以这个错误作为第一个参数并被调用。要确保可靠地检测到写入错误，应该监听 'error' 事件。

在确认了 chunk 后，如果内部缓冲区的大小小于创建流时设定的 highWaterMark 阈值，函数将返回 true 。 如果返回值为 false ，应该停止向流中写入数据，直到 'drain' 事件被触发。

当一个流不处在 drain 的状态， 对 write() 的调用会缓存数据块， 并且返回 false。 一旦所有当前所有缓存的数据块都排空了（被操作系统接受来进行输出）， 那么 'drain' 事件就会被触发。 我们建议， 一旦 write() 返回 false， 在 'drain' 事件触发前， 不能写入任何数据块。 然而，当流不处在 'drain' 状态时， 调用 write() 是被允许的， Node.js 会缓存所有已经写入的数据块， 直到达到最大内存占用， 这时它会无条件中止。 甚至在它中止之前， 高内存占用将会导致差的垃圾回收器的性能和高的系统相对敏感性 （即使内存不再需要，也通常不会被释放回系统）。 如果远程的另一端没有读取数据， TCP sockets 可能永远也不会 drain ， 所以写入到一个不会drain的socket可能会导致远程可利用的漏洞。

对于一个 Transform, 写入数据到一个不会drain的流尤其成问题， 因为 Transform 流默认被暂停， 直到它们被pipe或者被添加了 'data' 或 'readable' 事件处理函数。

如果将要被写入的数据可以根据需要生成或者取得，我们建议将逻辑封装为一个可读流并且使用 stream.pipe()。 但是如果调用 write() 优先, 那么可以使用 'drain' 事件来防止回压并且避免内存问题:

```
const fs = require('fs');

//没有就自动生成文件
const path = './lesson2.txt',
    options = {},
    writable = fs.createWriteStream(path, options);

//写死结束
write('我就随便写点什么吧！', () => {
    console.log('write completed, do more writes now');
});
writable.end();

//做简单判断，写入失败推到下一个
function write(data, cb) {
    if (!writable.write(data)) {
        //监听事件
        writable.once('drain', cb);
    } else {
        process.nextTick(cb);
    }
}
```
LS2

对象模式的写入流将忽略 encoding 参数。



*writable.end([chunk][, encoding][, callback])*

|    参数 | 描述    |
| --- | --- |
|  chunk（string，Buffer，Uint8Array，any）  |  可选的，需要写入的数据。对于非对象模式下的流， chunk 必须是字符串、或 Buffer、或 Uint8Array。对于对象模式下的流， chunk 可以是任意的 JavaScript 值，除了 null。 |
|  encoding（string）  |  如果 chunk 是字符串，这里指定字符编码。 |
|  callback（Function） |  可选的，流结束时的回调函数。  |

调用 writable.end() 方法表明接下来没有数据要被写入可写流。通过传入可选的 chunk 和 encoding 参数，可以在关闭流之前再写入一段数据。如果传入了可选的 callback 函数，它将作为 'finish' 事件的回调函数。

在调用了 stream.end() 方法之后，再调用 stream.write() 方法将会导致错误。

```
const fs = require('fs');

//没有就自动生成文件
const path = './lesson3.txt',
    options = {},
    writable = fs.createWriteStream(path, options);


//监听事件
writable.on('error', () => console.log('在调用了 stream.end() 方法之后不能再调用 stream.write() 方法'))

//写死结束
writable.end('我就随便写点什么吧！', null, () => console.log('你可以看看lesson3.txt写了什么了'));
writable.write('你就随便看看吧！');
```
LS3


*writable.destroy([error])*
摧毁这个流，并发出传过来的错误。当这个函数被调用后，这个写入流就结束了。 使用者不应该重写这个函数，而是重写 writable._destroy。

```
const fs = require('fs');

//没有就自动生成文件
const path = './lesson4.txt',
    options = {},
    writable = fs.createWriteStream(path, options);


//监听事件
writable.on('error', () => console.log('是我干的'))

//摧毁
writable.destroy();
```
LS4


*writable.cork()*
调用 writable.cork() 方法将强制所有写入数据都存放到内存中的缓冲区里。 直到调用 stream.uncork() 或 stream.end() 方法时，缓冲区里的数据才会被输出。

在向流中写入大量小块数据（small chunks of data）时，内部缓冲区（internal buffer）可能失效，从而导致性能下降。writable.cork() 方法主要就是用来避免这种情况。 对于这种情况， 实现了 writable._writev() 方法的流可以对写入的数据进行缓冲，从而提高写入效率。


*writable.uncork()*
将输出在 stream.cork() 方法被调用之后缓冲在内存中的所有数据。

如果使用 writable.cork() 和 writable.uncork() 来管理写入缓存，建议使用 process.nextTick() 来延迟调用 writable.uncork() 方法。通过这种方式，可以对单个 Node.js 事件循环中调用的所有 writable.write() 方法进行批处理。

如果一个流多次调用了 writable.cork() 方法，那么也必须调用同样次数的 writable.uncork() 方法以输出缓冲区数据。
```
const fs = require('fs');

//没有就自动生成文件
const path = './lesson5.txt',
    options = {},
    writable = fs.createWriteStream(path, options);

//写死结束
writable.cork();
writable.write('我就随便写点什么吧！');
writable.write('你就随便看看吧！');
process.nextTick(() => {
    writable.uncork();
    writable.end();
});
```
LS5



*writable.setDefaultEncoding(encoding)*
用于为可写流设置 encoding。


*writable属性*
writableHighWaterMark: 返回构造该可写流时传入的 highWaterMark 参数值。
writableLength: 这个属性包含了写入就绪队列的字节(或者对象)数，这个值提供了关于highWaterMark状态的内省数据。



### 实例
* [客户端上的 HTTP 请求](http://nodejs.cn/api/http.html#http_class_http_clientrequest)
* [服务器上的 HTTP 响应](http://nodejs.cn/api/http.html#http_class_http_serverresponse)
* [fs 写入的流](http://nodejs.cn/api/fs.html#fs_class_fs_writestream)
* [zlib 流](http://nodejs.cn/api/zlib.html)
* [crypto 流](http://nodejs.cn/api/crypto.html)
* [TCP socket](http://nodejs.cn/api/net.html#net_class_net_socket)
* [子进程 stdin](http://nodejs.cn/api/child_process.html#child_process_subprocess_stdin)
* [process.stdout](http://nodejs.cn/api/process.html#process_process_stdout)，[process.stderr](http://nodejs.cn/api/process.html#process_process_stderr)



## 可读流（stream.Readable  类）
可读流是对提供数据的来源的一种抽象，所有的可读流都实现了 stream.Readable 类上定义的接口。



### 实例
* [客户端上的 HTTP 请求](http://nodejs.cn/api/http.html#http_class_http_incomingmessage)
* [服务器上的 HTTP 响应](http://nodejs.cn/api/http.html#http_class_http_incomingmessage)
* [fs 写入的流](http://nodejs.cn/api/fs.html#fs_class_fs_readstream)
* [zlib 流](http://nodejs.cn/api/zlib.html)
* [crypto 流](http://nodejs.cn/api/crypto.html)
* [TCP socket](http://nodejs.cn/api/net.html#net_class_net_socket)
* [子进程 stdout 与 stderr](http://nodejs.cn/api/child_process.html#child_process_subprocess_stdout)
* [process.stdin](http://nodejs.cn/api/process.html#process_process_stdin)



## 对象模式
所有 Node.js API 创建的流都是专门运作在字符串和 Buffer（或 Uint8Array）对象上。 当然，流的实现也可以使用其它类型的 JavaScript 值（除了 null，因为它在流中有特殊用途）。 这些流会以“对象模式”进行操作。

当创建流时，可以使用 objectMode 选项把流实例切换到对象模式。 试图将已经存在的流切换到对象模式是不安全的。


## 缓冲
可写流和可读流都会在一个内部的缓冲器中存储数据，可以分别使用的 writable.writableBuffer 或 readable.readableBuffer 来获取。

可缓冲的数据的数量取决于传入流构造函数的 highWaterMark 选项。 对于普通的流，highWaterMark 选项指定了字节的总数量。 对于以对象模式运作的流，highWaterMark 指定了对象的总数量。

当调用 stream.push(chunk) 时，数据会被缓冲在可读流中。 如果流的消费程序没有调用 stream.read()，则这些数据会停留在内部队列中，直到被消费。

一旦内部的可读缓冲的总大小达到 highWaterMark 指定的阈值时，流会暂时停止从底层资源读取数据，直到当前缓冲的数据被消费 （也就是说，流会停止调用内部的用于填充可读缓冲的 readable._read() 方法）。

当反复地调用 writable.write(chunk) 方法时，数据会被缓冲在可写流中。 当内部的可写缓冲的总大小小于 highWaterMark 设置的阈值时，调用 writable.write() 会返回 true。 一旦内部缓冲的大小达到或超过 highWaterMark 时，则会返回 false。

stream API 的主要目标，特别是 stream.pipe() 方法，是为了限制数据的缓冲到可接受的程度，也就是读写速度不一致的源头与目的地不会压垮可用的内存。

因为 Duplex 和 Transform 都是可读又可写的，所以它们各自维护着两个相互独立的内部缓冲器用于读取和写入， 这使得它们在维护数据流时，读取和写入两边可以各自独立地运作。 例如，net.Socket 实例是 Duplex 流，它的可读端可以消费从 socket 接收的数据，而可写端则可以将数据写入到 socket。 因为数据写入到 socket 的速度可能比接收数据的速度快或者慢，所以在读写两端独立地进行操作（或缓冲）就显得很重要了。
