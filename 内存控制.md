## 瀏覽器内存
如果只接觸過前端的人應該都不熟悉這一塊内容，因爲以前前端作用不大，更加不會用到什麽大内存的操作，所以Javascript有自己的一套内存管理制度自動解決問題，我們不需要關心這些，可能瞭解也僅限於大概流程。
我以前在[Javascript难点知识运用---递归,闭包,柯里化等(不定时更新)](https://www.qdfuns.com/article/40831/c6ac1a16ad6d168e106a1c0916a6d7d9.html)裏垃圾收集章節總結過它兩種收集方式标记清除和引用计数，有興趣可以去看看

我們都知道Nodejs特性是基於異步無阻塞事件驅動型，特別擅長處理海量的網絡請求，所以面臨場景對資源有效利用性也比較看重，
因爲Nodejs是基於V8構建，所以我們需要先瞭解一下V8是怎麽進行分配管理的。

## V8對象分配
V8中所有JS對象都是通過堆進行分配的，當我們聲明並賦值時，使用對象的内存就分配在堆中，如果已申請的内存不夠分配新對象時就繼續申請直到超過V8限制爲止。
在Nodejs中通過JS使用的内存有限，64位系統大概1.4GB，32位系統約0.7GB。之所以有這樣限制外部原因是因爲V8最初是為瀏覽器而設計，並不需要有用到大内存的場景。内部原因是因爲V8垃圾回收機制的限制，垃圾回收會讓JS綫程暫時停止執行，官方説法以1.5G内存回收為例，一次小的垃圾回收需要50+毫秒，一次大的非增量式回收1+秒，會造成應用性能響應都直綫下降。

我們可以打開命令行執行如下命令，process.memoryUsage()會返回一組數據，单位都是字节。
PS C:\work\project\test> node
> process.memoryUsage()
{ rss: 23564288,
  heapTotal: 9232384,
  heapUsed: 5027992,
  external: 8748 }

rss（resident set size）：进程常驻内存，包含堆，栈，和代码段
heapTotal：已申请的堆内存
heapUsed：已使用的量
external：V8管理绑定到Javascript的C++对象的内存
进程的内存总共有几部分，一部分是rss ，其余部分在交换区（swap）或者文件系统（filesystem）中。

V8也提供了放寬限制的選項，在啓動nodejs的時候設置
node --max-old-space-size=  //單位MB
node --max-new-space-size=  //單位KB
設置在初始化生效之後不得動態更改，意味著不能自動根據情況擴充，内存分配過程超過限制會引起進程錯誤。


## V8的垃圾回收機制
### 内存分代
將内存分成存活時間較短的新生代對象和存活時間較長或常駐内存的老生代對象，組合起來就是V8堆整體大小。上面說的兩個設置選項就是這兩個對象。

### Scavenge算法
具體采用Cheney算法實現對新生代對象進行回收，Cheney是一種采用複製的方式，將對内存一分爲二，每部分空間稱爲semispace。一部分處於使用中稱爲From空間，另一部分處於閑置中稱爲To空間。
當我們分配對象時候會先分配在From空間，進行垃圾回收的時候會先檢查From空間的存活對象，然後將其複製到To空間，至於非存活對象會釋放空間，完成后From空間和To空間角色互換。
Scavenge算法優點是只複製存活對象，缺點是衹能利用一半的堆内存，這是一種由劃分空間和複製機制決定犧牲空間換時間的做法。所以其無法大規模應用到所有的垃圾回收，但是存活時間短的新生代對象非常合適使用。

而儅一個對象經過多次複製依然存活的情況下會被認爲是存活較久的老生代對象，於是被移動到老生帶中采用新的算法進行管理，這過程稱爲“晉升”。而“晉升”需要符合條件有兩種：
1，是否經歷過Scavenge回收；
2，To空間内存占比是否超過限制；
對象複製過程中會檢查它的内存地址判斷是否經歷過一次scavenge算法回收和To空間是否使用超過25%，之所以限制在25%是因爲回收完成之後兩個semispace空間角色互換，如果當前To空間内存占比過高會影響後續内存分配。
因爲老生代對象存活比重大，所以不適合Scavenge算法。


### Mark-Sweep && Mark-Compact
Mark-Sweep會在標記階段遍歷所有對象並標記活著的對象，沒有被標記的對象會在清除階段被清除，這種既不需要複製也不需要犧牲空間的方式最大的問題在於回收之後内存空間處於一種不連續的狀態。内存碎片化會影響後續的内存分配讓碎片内存得不到應用，儅無法完成分配的時候會提前觸發不必要的垃圾回收。
Mark-Compact是爲了解決碎片問題從Mark-Sweep基礎上演變出來，差別在於它會標記過程中移動存活對象，然後直接清理邊界外内存，因爲中間需要移動對象所以效率會低於Mark-Sweep。
V8主要使用Mark-Sweep，直到空間不足于分配“晉升”對象時才使用Mark-Compact。

### Incremental Marking
爲了避免JS應用邏輯和垃圾回收器情況不一致，上面算法都會在回收過程中暫停執行應用邏輯，這種行爲叫“全停頓”（stop-the-world）。
因爲V8老生代通常配置較大，存活對象多，標記，整理，清除步驟較久，V8會在標記階段改用增量標記（Incremental Marking），把連續動作拆分多個小動作，每個動作間隙中執行一會JS邏輯。即垃圾回收和應用邏輯交替執行直到標記階段完成。垃圾回收最大停頓時間可以減少到原有1/6左右。

### 其餘
V8後續還引入了延遲清理（lazy sweeping）和增量式整理（incremental compaction），並行標記與並行清理等，進一步利用多核性能降低每次停頓時間。

## 小結
從V8對內存進行限制的設計角度來說：
1，瀏覽器每個選項卡頁面使用一個V8實例的內存是綽綽有餘的；
2，新生代對象相對內存佔用少，存活佔比小，影響不大；
3，老生代對象內存過大對於垃圾回收沒有特別意義；
Nodejs服務端正常場景下使用沒有問題，只是需要注意JS單線程的執行情況和垃圾回收特點對性能的影響，特別是老生代對象過大會造成內存緊張，清理過程費時停頓。



## 查看垃圾回收內存
輸入命令行的時候我們可以加上  

--trace_gc 參數 ，在進行垃圾回收时，將会从標準輸出中打印垃圾回收信息。
\> xx.log參數 將標準輸出寫出指定的log文件生成在當前目錄。

我们先创建 lesson1.js 文件遍历一百万次插入数据。
```
var i = 0,
    len = 1000000,
    ary = [];
for (; i < len; i++) {
    ary.push(new Array(100))
}
```
LS1
然后当前目录启动终端输入 node --trace_gc lesson1 > gc.log，执行完之后会看到目录下生成一个 gc.log 文本，里面大概有这些信息

> [25164:000002B6E5994800]       40 ms: Scavenge 2.6 (3.8) -> 2.4 (4.8) MB, 1.7 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       50 ms: Scavenge 2.8 (4.8) -> 2.7 (5.8) MB, 1.2 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       77 ms: Scavenge 4.0 (5.8) -> 3.9 (8.8) MB, 0.8 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       80 ms: Scavenge 5.1 (8.8) -> 5.1 (8.8) MB, 1.7 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       82 ms: Scavenge 5.8 (8.8) -> 5.8 (14.3) MB, 1.2 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       85 ms: Scavenge 9.0 (14.3) -> 8.9 (15.3) MB, 1.5 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       87 ms: Scavenge 9.6 (15.3) -> 9.5 (26.3) MB, 1.8 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       97 ms: Scavenge 17.1 (27.8) -> 17.2 (28.3) MB, 4.1 / 0.0 ms  allocation failure
[25164:000002B6E5994800]      102 ms: Scavenge 17.7 (28.3) -> 17.4 (51.8) MB, 4.8 / 0.0 ms  allocation failure
[25164:000002B6E5994800]      116 ms: Scavenge 32.6 (51.8) -> 32.8 (52.3) MB, 5.6 / 0.0 ms  allocation failure
[25164:000002B6E5994800]      122 ms: Scavenge 33.1 (52.3) -> 32.3 (67.8) MB, 5.6 / 0.0 ms  allocation failure
[25164:000002B6E5994800]      233 ms: Mark-sweep 145.2 (178.7) -> 142.7 (177.2) MB, 1.8 / 0.0 ms  (+ 2.5 ms in 4 steps since start of marking, biggest step 1.4 ms, walltime since start of marking 31 ms) finalize incremental marking via stack guard GC in old space requested
[25164:000002B6E5994800]      371 ms: Mark-sweep 274.5 (311.2) -> 271.1 (310.3) MB, 2.3 / 0.0 ms  (+ 3.5 ms in 56 steps since start of marking, biggest step 0.8 ms, walltime since start of marking 47 ms) finalize incremental marking via stack guard GC in old space requested
[25164:000002B6E5994800]      627 ms: Mark-sweep 543.6 (587.4) -> 536.2 (580.0) MB, 2.5 / 0.0 ms  (+ 14.9 ms in 318 steps since start of marking, biggest step 0.7 ms, walltime since start of marking 104 ms) finalize incremental marking via stack guard GC in old space requested

以类似信息第一条为例
[25164:000002B6E5994800]       40 ms: Scavenge 2.6 (3.8) -> 2.4 (4.8) MB, 1.7 / 0.0 ms  allocation failure
执行40ms后使用Scavenge算法对新生代对象进行垃圾回收
[25164:000002B6E5994800]      233 ms: Mark-sweep 145.2 (178.7) -> 142.7 (177.2) MB, 1.8 / 0.0 ms  (+ 2.5 ms in 4 steps since start of marking, biggest step 1.4 ms, walltime since start of marking 31 ms) finalize incremental marking via stack guard GC in old space requested
执行233ms后使用Mark-sweep算法对老生代对象进行垃圾回收


如果启动时候加上--prof参数可以得到V8执行时的性能分析数据，其中也包括了垃圾回收执行时占用时间比。
当前目录启动终端输入 node --prof lesson1，执行完之后会看到目录下生成一个 xx-v8.log 文本，该文本不具有可读性，里面大概有巨量的信息，没办法直接贴出来，反正我是看不出什么了。
V8提供了 windows/linux-tick-processor工具 用于统计日志信息，就在Nodejs源码的 deps/v8/tools 目录下，可以将它配置到环境变量 PATH 路径直接调用
windows/linux-tick-processor v8.log
我嫌麻烦没去试，你们可以试试。


## 高效使用内存
其实就是编写代码的时候注意全局变量，作用域销毁，作用域链查找深度，无用变量回收，创建闭包等占用内存的问题。


## 内存指标
### 查看内存情况
除了我们上面说过的 process.memoryUsage() 以外，os模块 中的 taotalmem() 和 freemem() 方法也可以查看。

### 查看进程的内存占用
process.memoryUsage()是返回进程的内存占用，为了更好观察效果，我们用上面的代码改装一下，首先更加直观地格式化输出效果。
```
//打印内存使用
function show() {
    var info = process.memoryUsage(),
        format = function(bytes) {
            return (bytes / 1024 / 1024).toFixed(2) + ' MB'
        };

    console.log('Process: heapTotal ' + format(info.heapTotal) + ' heapUsed ' + format(info.heapUsed) + ' rss ' + format(info.rss));
    console.log('-----------------------------------------------------------');
}
```
在不断遍历循环占用内存，并且每次遍历都输出内存结果，因为windows系统限制大概在1.4G，我们设置15* 1024 * 1024长度使用让它溢出退出。
```
//创建内存操作
function create() {
    var use = function() {
            var size = 15* 1024 * 1024,
                arr = new Array(size),
                i = 0;
            for (; i < size; i++) {
                arr[i] = 0;
            }
            return arr;
        },
        total = [],
        j = 0;

    for (; j < 15; j++) {
        show();
        total.push(use());
    }
}
```
LS2
输出结果大概如下
```
Process: heapTotal 5.80 MB heapUsed 3.57 MB rss 19.38 MB
-----------------------------------------------------------
Process: heapTotal 167.32 MB heapUsed 164.15 MB rss 180.49 MB
-----------------------------------------------------------
Process: heapTotal 327.33 MB heapUsed 324.15 MB rss 340.57 MB
-----------------------------------------------------------
Process: heapTotal 487.34 MB heapUsed 484.16 MB rss 500.67 MB
-----------------------------------------------------------
Process: heapTotal 647.35 MB heapUsed 644.16 MB rss 660.73 MB
-----------------------------------------------------------
Process: heapTotal 807.36 MB heapUsed 804.16 MB rss 820.75 MB
-----------------------------------------------------------
Process: heapTotal 969.88 MB heapUsed 963.65 MB rss 981.10 MB
-----------------------------------------------------------
Process: heapTotal 1129.89 MB heapUsed 1123.65 MB rss 1141.19 MB
-----------------------------------------------------------
Process: heapTotal 1289.90 MB heapUsed 1283.65 MB rss 1301.21 MB
-----------------------------------------------------------

<--- Last few GCs --->

[15916:000001C1B178A0E0]     1657 ms: Mark-sweep 1283.6 (1290.3) -> 1283.6 (1290.3) MB, 157.3 / 0.0 ms  allocation failure GC in old space requested
[15916:000001C1B178A0E0]     1801 ms: Mark-sweep 1283.6 (1290.3) -> 1283.6 (1287.3) MB, 143.8 / 0.0 ms  last resort GC in old space requested
[15916:000001C1B178A0E0]     1948 ms: Mark-sweep 1283.6 (1287.3) -> 1283.6 (1287.3) MB, 147.2 / 0.0 ms  last resort GC in old space requested


<--- JS stacktrace --->

==== JS stack trace =========================================

    0: ExitFrame [pc: 000003B290B04281]
Security context: 000003CAA1FA06A9 <JSObject>
    1: useMem [C:\project\test\memory-demo\lesson2.js:~14] [pc=000003B290BEC8FA](this=0000016A71A06489 <JSGlobal Object>)
    2: create [C:\project\test\memory-demo\lesson2.js:28] [bytecode=000002D416667091 offset=35](this=0000016A71A06489 <JSGlobal Object>)
    3: /* anonymous */ [C:\project\test\memory-demo\lesson2.js:32] [bytecode=000002D416666309 off...

FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory
 1: node::DecodeWrite
 2: node_module_register
 3: v8::internal::FatalProcessOutOfMemory
 4: v8::internal::FatalProcessOutOfMemory
 5: v8::internal::Heap::MaxHeapGrowingFactor
 6: v8::internal::Factory::NewUninitializedFixedArray
 7: v8_inspector::V8StackTraceId::V8StackTraceId
 8: v8_inspector::V8StackTraceId::V8StackTraceId
 9: v8_inspector::V8StackTraceId::V8StackTraceId
10: v8::internal::interpreter::operator<<
11: 000003B290B04281
```

最后一次循环停在
Process: heapTotal 1289.90 MB heapUsed 1283.65 MB rss 1301.21 MB
后面进行几次垃圾回收，最终宣告内存溢出
FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory


### 查看系统的内存占用
 totalmem() 和 freemem() 返回的是系统的内存使用情况，因为 os模块 是Nodejs的核心模块，所以不需要额外引入，直接在Nodejs终端执行。
 ```
PS C:\project\test\memory-demo> node
> (os.totalmem() / 1024 / 1024 / 1024).toFixed(2) + ' GB'
'7.91 GB'
> (os.freemem() / 1024 / 1024 / 1024).toFixed(2) + ' GB'
'2.52 GB'
```
我电脑的总内存和限制内存如上。



### 堆外内存
从  process.momoryUsage() 输出结果可以看到，堆内存总是少于进程的常驻内存，这是因为Nodejs中的内存不全是V8分配的，非V8分配的内存被称为堆外内存。
我们将上面的方法修改一下，用 Buffer 替代 Array，然后扩大使用内存看看效果。
```
//创建内存操作
function create() {
    var use = function() {
            var size = 200 * 1024 * 1024,
                arr = new Buffer(size),
                i = 0;
            for (; i < size; i++) {
                arr[i] = 0;
            }
            return arr;
        },
        total = [],
        j = 0;

    for (; j < 15; j++) {
        show();
        total.push(use());
    }
}
```
输出结果如下
```
Process: heapTotal 5.80 MB heapUsed 3.57 MB rss 19.36 MB
-----------------------------------------------------------
Process: heapTotal 7.80 MB heapUsed 4.34 MB rss 220.83 MB
-----------------------------------------------------------
Process: heapTotal 7.80 MB heapUsed 4.36 MB rss 421.02 MB
-----------------------------------------------------------
Process: heapTotal 9.80 MB heapUsed 4.06 MB rss 621.36 MB
-----------------------------------------------------------
Process: heapTotal 9.80 MB heapUsed 4.06 MB rss 821.36 MB
-----------------------------------------------------------
Process: heapTotal 9.80 MB heapUsed 3.82 MB rss 1021.40 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.77 MB rss 1221.72 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.77 MB rss 1421.72 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.78 MB rss 1621.73 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.77 MB rss 1821.73 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.77 MB rss 2021.74 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.78 MB rss 2221.74 MB
-----------------------------------------------------------
Process: heapTotal 7.30 MB heapUsed 3.75 MB rss 2420.73 MB
-----------------------------------------------------------
Process: heapTotal 7.30 MB heapUsed 3.75 MB rss 2620.73 MB
-----------------------------------------------------------
Process: heapTotal 7.30 MB heapUsed 3.75 MB rss 2820.73 MB
-----------------------------------------------------------
(node:15428) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.
```
可以看到这次尽管扩大十倍，但是没有发生内存溢出，而且 heapTotal 和 heapUsed 基本持平，唯有rss不断扩充甚至远远超过V8限制值了。这是因为Buffer对象不经过V8内存分配，所以可以无视堆内存的大小限制。

本来开始是打算写关于Buffer对象的，然后因为它需要涉及到内存的知识点，所以先学习这一章，终端报出用法废弃先不管，下一章再去研究Buffer对象。



## 内存泄露
Nodejs擅长高并发场景，同样也对内存泄露特别敏感，而且通常无意间造成的问题难以排查，但基本原因都是以你为本该回收的对象没有回收以至于变成常驻老生代对象，可能原因有几个：
* 缓存
* 队列消费不及时
* 作用域未释放

###缓存
缓存也分两种，一种是严格意义上的如浏览器，Nodejs等有完善过期策略缓存，一种代码常用的普通对象键值缓存等，可能如下。
```
var cache = {},
    get = function(key, val) {
        return cache[key] ? cache[key] : cache[key] = val;
    };

console.log(get('ac', 12));
console.log(get('ac', 12));
console.log('cache: ', cache);
//12
//12
//cache:  { ac: 12 }
```
如果没做基本限制使用条件，在浏览器这种短时应用场景问题不大，但在Nodejs这种执行量大和参数多样性的使用环境会造成占用过多内存不释放，需要非常谨慎。

1，缓存限制策略
懒得写了，直接搬朴灵写的limitablemap模块实现。
```
var LimitableMap = function(limit) {
    this.limit = limit || 10;
    this.map = {};
    this.keys = [];
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
LimitableMap.prototype.set = function(key, value) {
    var map = this.map;
    var keys = this.keys;
    if (!hasOwnProperty.call(map, key)) {
        if (keys.length === this.limit) {
            var firstKey = keys.shift();
            delete map[firstKey];
        }
        keys.push(key);
    }
    map[key] = value;
};
LimitableMap.prototype.get = function(key) {
    return this.map[key];
};
module.exports = LimitableMap;
```
基本原理就是设置一个限定值，每当达到阈值的时候就移除头部缓存。

还有其他如模块机制的缓存是常驻老生代的，上一章节讲过Nodejs会将编译执行过后的模块缓存起来，然后通过 exports 变量访问里面的私有变量，导致私有变量作用域因为模块缓存原因不会被释放，而且能让私有变量不断增加占用内存。
```
(function(exports, require, module, __filename, __dirname) {
    var ary = [];
    exports.get = function() {
        return ary;
    };
    exports.add = function(val) {
        ary.push(val);
    };
});
```


### 缓存解决方案
因为进程之间无法共享内存，所以进程间不可避免有些重复缓存，目前比较好的方案是采用进程外的缓存。

* 缓存转移到外部减少常驻内存对象数量
* 进程可以共享外部缓存

广为人知的有 Redis 和 Memcached。



## 队列状态
JS中我们也经常使用队列来控制事件，如果消费速度远低于生产速度就会形成堆积最后形成内存泄漏。
例如有些应用会采用数据库记录海量日志，而数据库又构建在文件系统之上而写入效率远低于直接写入文件系统，于是写入操作慢慢堆积导致相关作用域得不到释放占用大量内存最后出现内存泄漏。
这是提高消费速度的情况，同样也有抑制生产速度的情况出现。
一般解决方案有
监控队列长度，达到阈值通过监控系统报警并通知相关人员
超时机制，保证限定时间内未完成响应调用相关操作终止
拒绝模式，达到阈值之后不再接收新的生产事件


## 内存泄漏排查
*  node-heapdump 这是Node 核心贡献者之一Ben Noordhuis编写的模块，它允许对V8对堆内存抓取快照，用于事后分析。
*  node-memwatch 来自Mozilla的Lloyd Hilaiel贡献的模块，采用WTFPL许可发布。


## 大内存应用
Nodejs提供了 Stream模块 用于处理大文件，它继承自 EventEmitter ，所以具备基本的自定义事件功能，同时抽象出标准的事件和方法，Nodejs大多数模块都会用到 Stream模块，得益于它实现方式不受V8内存限制，有效提高代码健壮性。

稍后也准备写一篇关于Stream模块的东西，如果内容不多的话就搭配 Buffer模块一起了。
