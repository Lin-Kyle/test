##瀏覽器内存
如果只接觸過前端的人應該都不熟悉這一塊内容，因爲以前前端作用不大，更加不會用到什麽大内存的操作，所以Javascript有自己的一套内存管理制度自動解決問題，我們不需要關心這些，可能瞭解也僅限於大概流程。
我以前在[Javascript难点知识运用---递归,闭包,柯里化等(不定时更新)](https://www.qdfuns.com/article/40831/c6ac1a16ad6d168e106a1c0916a6d7d9.html)裏垃圾收集章節總結過它兩種收集方式标记清除和引用计数，有興趣可以去看看

我們都知道Nodejs特性是基於異步無阻塞事件驅動型，特別擅長處理海量的網絡請求，所以面臨場景對資源有效利用性也比較看重，
因爲Nodejs是基於V8構建，所以我們需要先瞭解一下V8是怎麽進行分配管理的。

##V8對象分配
V8中所有JS對象都是通過堆進行分配的，當我們聲明並賦值時，使用對象的内存就分配在堆中，如果已申請的内存不夠分配新對象時就繼續申請直到超過V8限制爲止。
在Nodejs中通過JS使用的内存有限，64位系統大概1.4GB，32位系統約0.7GB。之所以有這樣限制外部原因是因爲V8最初是為瀏覽器而設計，並不需要有用到大内存的場景。内部原因是因爲V8垃圾回收機制的限制，垃圾回收會讓JS綫程暫時停止執行，官方説法以1.5G内存回收為例，一次小的垃圾回收需要50+毫秒，一次大的非增量式回收1+秒，會造成應用性能響應都直綫下降。

我們可以打開命令行執行如下命令，process.memoryUsage()會返回一組數據，单位都是字节。
PS C:\work\project\test> node
> process.memoryUsage()
{ rss: 23564288,
  heapTotal: 9232384,
  heapUsed: 5027992,
  external: 8748 }

rss：进程常驻内存，包含堆，栈，和代码段
heapTotal：已申请的堆内存
heapUsed：已使用的量
external：V8管理绑定到Javascript的C++对象的内存

V8也提供了放寬限制的選項，在啓動nodejs的時候設置
node --max-old-space-size=  //單位MB
node --max-new-space-size=  //單位KB
設置在初始化生效之後不得動態更改，意味著不能自動根據情況擴充，内存分配過程超過限制會引起進程錯誤。


##V8的垃圾回收機制
###内存分代
將内存分成存活時間較短的新生代對象和存活時間較長或常駐内存的老生代對象，組合起來就是V8堆整體大小。上面說的兩個設置選項就是這兩個對象。

###Scavenge算法
具體采用Cheney算法實現對新生代對象進行回收，Cheney是一種采用複製的方式，將對内存一分爲二，每部分空間稱爲semispace。一部分處於使用中稱爲From空間，另一部分處於閑置中稱爲To空間。
當我們分配對象時候會先分配在From空間，進行垃圾回收的時候會先檢查From空間的存活對象，然後將其複製到To空間，至於非存活對象會釋放空間，完成后From空間和To空間角色互換。
Scavenge算法優點是只複製存活對象，缺點是衹能利用一半的堆内存，這是一種由劃分空間和複製機制決定犧牲空間換時間的做法。所以其無法大規模應用到所有的垃圾回收，但是存活時間短的新生代對象非常合適使用。

而儅一個對象經過多次複製依然存活的情況下會被認爲是存活較久的老生代對象，於是被移動到老生帶中采用新的算法進行管理，這過程稱爲“晉升”。而“晉升”需要符合條件有兩種：
1，是否經歷過Scavenge回收；
2，To空間内存占比是否超過限制；
對象複製過程中會檢查它的内存地址判斷是否經歷過一次scavenge算法回收和To空間是否使用超過25%，之所以限制在25%是因爲回收完成之後兩個semispace空間角色互換，如果當前To空間内存占比過高會影響後續内存分配。
因爲老生代對象存活比重大，所以不適合Scavenge算法。


###Mark-Sweep && Mark-Compact
Mark-Sweep會在標記階段遍歷所有對象並標記活著的對象，沒有被標記的對象會在清除階段被清除，這種既不需要複製也不需要犧牲空間的方式最大的問題在於回收之後内存空間處於一種不連續的狀態。内存碎片化會影響後續的内存分配讓碎片内存得不到應用，儅無法完成分配的時候會提前觸發不必要的垃圾回收。
Mark-Compact是爲了解決碎片問題從Mark-Sweep基礎上演變出來，差別在於它會標記過程中移動存活對象，然後直接清理邊界外内存，因爲中間需要移動對象所以效率會低於Mark-Sweep。
V8主要使用Mark-Sweep，直到空間不足于分配“晉升”對象時才使用Mark-Compact。

###Incremental Marking
爲了避免JS應用邏輯和垃圾回收器情況不一致，上面算法都會在回收過程中暫停執行應用邏輯，這種行爲叫“全停頓”（stop-the-world）。
因爲V8老生代通常配置較大，存活對象多，標記，整理，清除步驟較久，V8會在標記階段改用增量標記（Incremental Marking），把連續動作拆分多個小動作，每個動作間隙中執行一會JS邏輯。即垃圾回收和應用邏輯交替執行直到標記階段完成。

###lazy Sweeping

###incremental compaction
