##瀏覽器内存
如果只接觸過前端的人應該都不熟悉這一塊内容，因爲以前前端作用不大，更加不會用到什麽大内存的操作，所以Javascript有自己的一套内存管理制度自動解決問題，我們不需要關心這些，可能瞭解也僅限於大概流程。
我以前在[Javascript难点知识运用---递归,闭包,柯里化等(不定时更新)](https://www.qdfuns.com/article/40831/c6ac1a16ad6d168e106a1c0916a6d7d9.html)裏垃圾收集章節總結過它兩種收集方式标记清除和引用计数，有興趣可以去看看

我們都知道Nodejs特性是基於異步無阻塞事件驅動型，特別擅長處理海量的網絡請求，所以面臨場景對資源有效利用性也比較看重，
因爲Nodejs是基於V8構建，所以我們需要先瞭解一下V8是怎麽進行分配管理的。

##V8對象分配
V8中所有JS對象都是通過堆進行分配的，當我們聲明並賦值時，使用對象的内存就分配在堆中，如果已申請的内存不夠分配新對象時就繼續申請直到超過V8限制爲止。
在Nodejs中通過JS使用的内存有限，64位系統大概1.4GB，32位系統約0.7GB。之所以有這樣限制外部原因是因爲V8最初是為瀏覽器而設計，並不需要有用到大内存的場景。内部原因是因爲V8垃圾回收機制的限制，垃圾回收會讓JS綫程暫時停止執行，官方説法以1.5G内存回收為例，一次小的垃圾回收需要50+毫秒，一次大的非增量式回收1+秒，會造成應用性能響應都直綫下降。

我們可以打開命令行執行如下命令，process.memoryUsage()會返回一組數據，单位都是字节。
PS C:\work\project\test> node
> process.memoryUsage()
{ rss: 23564288,
  heapTotal: 9232384,
  heapUsed: 5027992,
  external: 8748 }

rss：进程常驻内存，包含堆，栈，和代码段
heapTotal：已申请的堆内存
heapUsed：已使用的量
external：V8管理绑定到Javascript的C++对象的内存

V8也提供了放寬限制的選項，在啓動nodejs的時候設置
node --max-old-space-size=  //單位MB
node --max-new-space-size=  //單位KB
設置在初始化生效之後不得動態更改，意味著不能自動根據情況擴充，内存分配過程超過限制會引起進程錯誤。


##V8的垃圾回收機制
###内存分代
將内存分成存活時間較短的新生代對象和存活時間較長或常駐内存的老生代對象，組合起來就是V8堆整體大小。上面說的兩個設置選項就是這兩個對象。

###Scavenge算法
