## 前期准备
因为这里会需要用到 curl 工具测试所以先来一波安装教程，先去网站安装一个版本工具。
[curl](https://curl.haxx.se/download/?C=M;O=D)，我直接下载的下curl-7.20.0.zip，把文件解压出来然后在该目录下调用终端输入

垃圾回收（garbage collector），下面统称GC。
xx，代表随意名字或者自定义名字或者无规律程序自动分配名字。

## 瀏覽器内存
如果只接觸過前端的人應該都不熟悉這一塊内容，因爲在浏览器开发很少会遇到内存问题，更加不會用到什麽大内存的操作，所以Javascript有自己的一套内存管理制度自動解決問題，我們不需要關心這些，可能瞭解也僅限於大概流程。
我以前在[Javascript难点知识运用---递归,闭包,柯里化等(不定时更新)](https://www.qdfuns.com/article/40831/c6ac1a16ad6d168e106a1c0916a6d7d9.html)裏垃圾收集章節總結過它兩種收集方式标记清除和引用计数，有興趣可以去看看。


## Nodejs内存
我們都知道 Nodejs 特性是基於異步無阻塞事件驅動型，因此内存消耗低特別擅長處理海量的網絡請求。但是在海量请求和长时间运行的前提下，开发者需要考虑一些平时不需要关注的问题，如何可以最大限度高效利用一切资源就成了 Nodejs 服务端性能关键之一了。
因爲 Nodejs 是基於V8引擎構建，所以我們需要先瞭解一下V8是怎麽進行内存分配管理的。

### V8對象分配
在 Nodejs 中通過JS使用的内存有限，64位系統大概1.4GB，32位系統約0.7GB，这就导致Nodejs无法直接操作大内存对象，比如无法将2GB文件读入内存中进行字符串分析处理，即使物理内存有32GB，在单个Nodejs进程下计算机内存资源无法得到充分利用。

之所以有這樣限制表层原因是因爲V8最初是為瀏覽器而設計，並不需要有用到大内存的場景。深层原因是因爲V8的GC機制的限制。GC會讓JS綫程暫時停止執行，官方説法以1.5G内存回收為例，一次小的GC需要50+毫秒，一次大的非增量式回收1+秒，會造成應用性能響應都直綫下降，甚至一不小心触碰界限就会造成进程退出。

V8中所有JS對象都是通過堆進行分配的，當我們聲明变量並賦值時，所使用對象的内存就分配在堆中，如果已申請的内存不夠分配新對象時就繼續申請堆内存直到超過V8限制爲止。

我們可以打開命令行執行如下命令，process.memoryUsage() 會返回一組數據，单位都是字节。
> PS C:\work\project\test> node
process.memoryUsage()
{ rss: 23564288,
  heapTotal: 9232384,
  heapUsed: 5027992,
  external: 8748 }

rss（resident set size）：进程常驻内存，包含堆，栈，和代码段
heapTotal：已申请的堆内存
heapUsed：已使用的量
external：V8管理绑定到Javascript的C++对象的内存
进程的内存总共有几部分，一部分是rss ，其余部分在 交换区（swap）或者 文件系统（filesystem）中。

V8也提供了放寬限制的選項，在啓動 Nodejs 的時候設置
node --max-old-space-size=xx  xx.js//單位MB
node --max-new-space-size=xx  xx.js//單位KB
具体用法区别下面会说，现在先记住该設置在V8初始化生效之後不得再動態更改，这就意味著应用运行期间不能自動根據情況自动扩充，内存分配過程超過限制就會引起進程錯誤。


## V8的GC機制
V8的GC策略主要是基于分代式机制，因为实际应用对象的生存周期长短不一，现代的GC算法按对象的存活时间进行不同分代采用不同的算法执行。

### 内存分代
V8將内存分成存活時間較短的新生代對象和存活時間較長或常駐内存的老生代對象，两者組合起來就是V8堆内存整體大小。上面說的兩個設置選項就是這兩個對象。

### Scavenge算法
Scavenge算法具體采用 Cheney算法 實現，采用複製的方式將堆内存一分爲二，每部分空間稱爲 semispace（半空间）。一个處於使用中稱爲 From空間，另一个處於閑置中稱爲 To空間。
當我們分配對象時候會先分配在From空間，進行GC的時候會先檢查From空間的存活對象，然後將其複製到To空間，至於非存活對象會被釋放内存，完成复制后From空間和To空間角色互換。
Scavenge算法優點是只複製存活對象，缺點是衹能利用一半的堆内存，這是一種由劃分空間和複製機制決定的犧牲空間換時間的做法。所以無法大規模應用到所有的GC。
在分代的基础上生命周期短暂的新生代对象非常适合通过这种算法进行GC。

而儅一個對象經過多次複製依然存活的情況下會被認爲是生命周期较长的對象，於是会被移動到老生帶中采用新的算法進行管理，這過程稱爲“晉升”。而“晉升”需要符合條件有兩種：

1，對象是否經歷過Scavenge回收（前提得經過多次複製依然存活）；
2，To空間内存占比是否超過限制；

在分代式GC的前提下，From空间對象複製之前會檢查它的内存地址判斷是否經歷過一次scavenge算法回收和To空間是否使用超過25%，之所以限制在25%是因爲回收完成之後兩個semispace空間角色互換，如果當前To空間内存占比過高會影響後續内存分配。
因爲老生代對象存活比重大，所以不適合Scavenge算法。


### Mark-Sweep && Mark-Compact
Mark-Sweep 會在標記階段遍歷堆中所有對象並標記活著的對象，沒有被標記的對象會在清除階段被释放，這種既不需要複製也不需要犧牲空間的方式最大的問題在於回收之後内存空間處於一種不連續的狀態。内存碎片化會影響後續的内存分配讓碎片内存得不到應用，儅無法完成分配的時候會提前觸發不必要的GC。
Mark-Compact 是爲了解決碎片問題從Mark-Sweep基礎上演變出來，差別在於它會在標記過程中移動存活對象，然後直接清理邊界外内存，因爲中間需要移動對象所以效率會低於 Mark-Sweep。
V8主要使用Mark-Sweep，直到空間不足于分配“晉升”對象時才使用Mark-Compact。

### Incremental Marking
爲了避免JS應用邏輯和GC器情況不一致，上面算法都會在回收期间暫停執行應用邏輯，這種行爲叫“全停頓”（stop-the-world）。
因爲V8老生代通常配置較大，存活對象多，標記，整理，清除步驟較久，所以在標記階段改用增量標記（Incremental Marking），把連續動作拆分多個小動作，每個動作間隙中執行一會JS邏輯。即GC和應用邏輯交替執行直到標記階段完成，最大停頓時間可以減少到原有1/6左右。

### 基本对比
|回收算法|Scavenge|Mark-Sweep|Mark-Sweep|
|-|-|-|-|
|速度 | 最快|中等 |最慢 |
| 空间开销|双倍空间（无碎片） | 少（有碎片）|少（无碎片） |
| 是否移动对象| 是| 否|否 |

### 其餘
V8後續還引入了延遲清理（lazy sweeping）和增量式整理（incremental compaction），並行標記與並行清理等，進一步利用多核性能降低每次停頓時間。

## 小結
從V8對內存進行限制的設計角度來說：
1，瀏覽器每個選項卡頁面使用一個V8實例的內存是綽綽有餘的；
2，新生代對象相對內存佔用少，存活佔比小，影響不大；
3，老生代對象內存過大對於GC沒有特別意義；
 Nodejs 服務端正常場景下使用沒有問題，只是需要注意JS單線程的執行情況和GC特點對性能的影響，特別是老生代對象過大會造成內存緊張，清理過程費時停頓。



## 查看GC內存
启动的時候我們可以在命令加上  

--trace_gc參數：在進行GC时，將会从標準輸出中打印GC信息。
\> xx.log參數：在當前目錄下將標準輸出寫入/生成指定的log文件。

我们先创建 lesson1.js 文件遍历插入一百万条数据。
```
var i = 0,
    len = 1000000,
    ary = [];
for (; i < len; i++) {
    ary.push(new Array(100))
}
```
LS1
然后当前目录启动终端输入 node --trace_gc lesson1 > gc.log，执行完之后会看到目录下生成一个 gc.log 文本，里面大概有这些信息

> [25164:000002B6E5994800]       40 ms: Scavenge 2.6 (3.8) -> 2.4 (4.8) MB, 1.7 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       50 ms: Scavenge 2.8 (4.8) -> 2.7 (5.8) MB, 1.2 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       77 ms: Scavenge 4.0 (5.8) -> 3.9 (8.8) MB, 0.8 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       80 ms: Scavenge 5.1 (8.8) -> 5.1 (8.8) MB, 1.7 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       82 ms: Scavenge 5.8 (8.8) -> 5.8 (14.3) MB, 1.2 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       85 ms: Scavenge 9.0 (14.3) -> 8.9 (15.3) MB, 1.5 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       87 ms: Scavenge 9.6 (15.3) -> 9.5 (26.3) MB, 1.8 / 0.0 ms  allocation failure
[25164:000002B6E5994800]       97 ms: Scavenge 17.1 (27.8) -> 17.2 (28.3) MB, 4.1 / 0.0 ms  allocation failure
[25164:000002B6E5994800]      102 ms: Scavenge 17.7 (28.3) -> 17.4 (51.8) MB, 4.8 / 0.0 ms  allocation failure
[25164:000002B6E5994800]      116 ms: Scavenge 32.6 (51.8) -> 32.8 (52.3) MB, 5.6 / 0.0 ms  allocation failure
[25164:000002B6E5994800]      122 ms: Scavenge 33.1 (52.3) -> 32.3 (67.8) MB, 5.6 / 0.0 ms  allocation failure
[25164:000002B6E5994800]      233 ms: Mark-sweep 145.2 (178.7) -> 142.7 (177.2) MB, 1.8 / 0.0 ms  (+ 2.5 ms in 4 steps since start of marking, biggest step 1.4 ms, walltime since start of marking 31 ms) finalize incremental marking via stack guard GC in old space requested
[25164:000002B6E5994800]      371 ms: Mark-sweep 274.5 (311.2) -> 271.1 (310.3) MB, 2.3 / 0.0 ms  (+ 3.5 ms in 56 steps since start of marking, biggest step 0.8 ms, walltime since start of marking 47 ms) finalize incremental marking via stack guard GC in old space requested
[25164:000002B6E5994800]      627 ms: Mark-sweep 543.6 (587.4) -> 536.2 (580.0) MB, 2.5 / 0.0 ms  (+ 14.9 ms in 318 steps since start of marking, biggest step 0.7 ms, walltime since start of marking 104 ms) finalize incremental marking via stack guard GC in old space requested

以类似信息第一条为例
[25164:000002B6E5994800]       40 ms: Scavenge 2.6 (3.8) -> 2.4 (4.8) MB, 1.7 / 0.0 ms  allocation failure
执行40ms后使用Scavenge算法对新生代对象进行GC，使用内存从2.6->2.4，常驻内存从3.8->4.8.里面的“allocation failure”并不是真正的失败，只是代表着分配了这么多内存是时候该做个 GC 去看看能不能回收一些内存。

[25164:000002B6E5994800]      233 ms: Mark-sweep 145.2 (178.7) -> 142.7 (177.2) MB, 1.8 / 0.0 ms  (+ 2.5 ms in 4 steps since start of marking, biggest step 1.4 ms, walltime since start of marking 31 ms) finalize incremental marking via stack guard GC in old space requested
执行233ms后使用Mark-sweep算法对老生代对象进行GC，使用内存从145.2->142.7，常驻内存从178.7->177.2.


如果启动时候加上--prof参数可以得到V8执行时的性能分析数据，其中也包括了GC执行时占用时间比。
当前目录启动终端输入 node --prof lesson1，执行完之后会看到目录下生成一个 xx-v8.log 文本，该文本不具有可读性，里面有巨量的信息没办法直接贴出来，反正我是看不出什么。
V8提供了 windows/linux-tick-processor工具 用于统计日志信息，就在 Nodejs 源码的 deps/v8/tools 目录下，可以将它配置到环境变量 PATH 路径直接调用
windows/linux-tick-processor xx-v8.log
我嫌麻烦没去试，你们可以试试。


### 高效使用内存
其实就是编写代码的时候注意全局变量，作用域销毁，作用域链查找深度，无用变量回收，创建闭包等占用内存的问题,都是些基础常用知识，有兴趣可以参考我以前写的一篇科普文章。
[Javascript难点知识运用---递归,闭包,柯里化等(不定时更新)](https://www.qdfuns.com/article/40831/c6ac1a16ad6d168e106a1c0916a6d7d9.html)


## 内存指标
### 查看内存情况
除了我们上面说过的 process.memoryUsage() 以外，os模块 中的 taotalmem() 和 freemem() 方法也可以查看。

### 查看进程的内存占用
process.memoryUsage()是返回进程的内存占用，为了更好观察效果，我们用上面的代码改装一下，首先更加直观地格式化输出效果。
```
//打印内存使用
function show() {
    var info = process.memoryUsage(),
        format = function(bytes) {
            return (bytes / 1024 / 1024).toFixed(2) + ' MB'
        };

    console.log('Process: heapTotal ' + format(info.heapTotal) + ' heapUsed ' + format(info.heapUsed) + ' rss ' + format(info.rss));
    console.log('-----------------------------------------------------------');
}
```
再不断遍历循环占用内存，并且每次遍历都输出内存结果，因为windows系统限制大概在1.4G，我们设置15GB长度使用让它溢出。
```
//创建内存操作
function create() {
    var use = function() {
            var size = 15* 1024 * 1024,
                arr = new Array(size),
                i = 0;
            for (; i < size; i++) {
                arr[i] = 0;
            }
            return arr;
        },
        total = [],
        j = 0;

    for (; j < 15; j++) {
        show();
        total.push(use());
    }
}
```
LS2
输出结果大概如下
```
Process: heapTotal 5.80 MB heapUsed 3.57 MB rss 19.38 MB
-----------------------------------------------------------
Process: heapTotal 167.32 MB heapUsed 164.15 MB rss 180.49 MB
-----------------------------------------------------------
Process: heapTotal 327.33 MB heapUsed 324.15 MB rss 340.57 MB
-----------------------------------------------------------
Process: heapTotal 487.34 MB heapUsed 484.16 MB rss 500.67 MB
-----------------------------------------------------------
Process: heapTotal 647.35 MB heapUsed 644.16 MB rss 660.73 MB
-----------------------------------------------------------
Process: heapTotal 807.36 MB heapUsed 804.16 MB rss 820.75 MB
-----------------------------------------------------------
Process: heapTotal 969.88 MB heapUsed 963.65 MB rss 981.10 MB
-----------------------------------------------------------
Process: heapTotal 1129.89 MB heapUsed 1123.65 MB rss 1141.19 MB
-----------------------------------------------------------
Process: heapTotal 1289.90 MB heapUsed 1283.65 MB rss 1301.21 MB
-----------------------------------------------------------

<--- Last few GCs --->

[15916:000001C1B178A0E0]     1657 ms: Mark-sweep 1283.6 (1290.3) -> 1283.6 (1290.3) MB, 157.3 / 0.0 ms  allocation failure GC in old space requested
[15916:000001C1B178A0E0]     1801 ms: Mark-sweep 1283.6 (1290.3) -> 1283.6 (1287.3) MB, 143.8 / 0.0 ms  last resort GC in old space requested
[15916:000001C1B178A0E0]     1948 ms: Mark-sweep 1283.6 (1287.3) -> 1283.6 (1287.3) MB, 147.2 / 0.0 ms  last resort GC in old space requested


<--- JS stacktrace --->

==== JS stack trace =========================================

    0: ExitFrame [pc: 000003B290B04281]
Security context: 000003CAA1FA06A9 <JSObject>
    1: useMem [C:\project\test\memory-demo\lesson2.js:~14] [pc=000003B290BEC8FA](this=0000016A71A06489 <JSGlobal Object>)
    2: create [C:\project\test\memory-demo\lesson2.js:28] [bytecode=000002D416667091 offset=35](this=0000016A71A06489 <JSGlobal Object>)
    3: /* anonymous */ [C:\project\test\memory-demo\lesson2.js:32] [bytecode=000002D416666309 off...

FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory
 1: node::DecodeWrite
 2: node_module_register
 3: v8::internal::FatalProcessOutOfMemory
 4: v8::internal::FatalProcessOutOfMemory
 5: v8::internal::Heap::MaxHeapGrowingFactor
 6: v8::internal::Factory::NewUninitializedFixedArray
 7: v8_inspector::V8StackTraceId::V8StackTraceId
 8: v8_inspector::V8StackTraceId::V8StackTraceId
 9: v8_inspector::V8StackTraceId::V8StackTraceId
10: v8::internal::interpreter::operator<<
11: 000003B290B04281
```

最后一次循环停在
Process: heapTotal 1289.90 MB heapUsed 1283.65 MB rss 1301.21 MB
后面进行几次GC，最终宣告内存溢出
FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory


### 查看系统的内存占用
 totalmem() 和 freemem() 返回的是系统的内存使用情况，因为 os模块 是 Nodejs 的核心模块，所以不需要额外引入，直接在 Nodejs 终端执行。
 ```
PS C:\project\test\memory-demo> node
> (os.totalmem() / 1024 / 1024 / 1024).toFixed(2) + ' GB'
'7.91 GB'
> (os.freemem() / 1024 / 1024 / 1024).toFixed(2) + ' GB'
'2.52 GB'
```
可以得到我电脑的总内存和限制内存如上。



### 堆外内存
从  process.momoryUsage() 输出结果可以看到，堆内存总是少于进程的常驻内存，这是因为 Nodejs 中的内存不全是V8分配的，非V8分配的内存被称为堆外内存。
我们将上面的方法修改一下，用 Buffer 替代 Array，然后扩大使用内存看看效果。
```
//创建内存操作
function create() {
    var use = function() {
            var size = 200 * 1024 * 1024,
                arr = new Buffer(size),
                i = 0;
            for (; i < size; i++) {
                arr[i] = 0;
            }
            return arr;
        },
        total = [],
        j = 0;

    for (; j < 15; j++) {
        show();
        total.push(use());
    }
}
```
LS3
输出结果如下
```
Process: heapTotal 5.80 MB heapUsed 3.57 MB rss 19.36 MB
-----------------------------------------------------------
Process: heapTotal 7.80 MB heapUsed 4.34 MB rss 220.83 MB
-----------------------------------------------------------
Process: heapTotal 7.80 MB heapUsed 4.36 MB rss 421.02 MB
-----------------------------------------------------------
Process: heapTotal 9.80 MB heapUsed 4.06 MB rss 621.36 MB
-----------------------------------------------------------
Process: heapTotal 9.80 MB heapUsed 4.06 MB rss 821.36 MB
-----------------------------------------------------------
Process: heapTotal 9.80 MB heapUsed 3.82 MB rss 1021.40 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.77 MB rss 1221.72 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.77 MB rss 1421.72 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.78 MB rss 1621.73 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.77 MB rss 1821.73 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.77 MB rss 2021.74 MB
-----------------------------------------------------------
Process: heapTotal 10.30 MB heapUsed 3.78 MB rss 2221.74 MB
-----------------------------------------------------------
Process: heapTotal 7.30 MB heapUsed 3.75 MB rss 2420.73 MB
-----------------------------------------------------------
Process: heapTotal 7.30 MB heapUsed 3.75 MB rss 2620.73 MB
-----------------------------------------------------------
Process: heapTotal 7.30 MB heapUsed 3.75 MB rss 2820.73 MB
-----------------------------------------------------------
(node:15428) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.
```
可以看到这次尽管数据量扩大十倍，但是没有发生内存溢出，而且 heapTotal 和 heapUsed 基本持平，唯有rss不断扩充甚至远远超过V8限制值了。这是因为Buffer对象不经过V8内存分配，所以可以无视堆内存的大小限制。

本来开始是打算写关于Buffer对象的，然后因为它需要涉及到内存的知识点，所以先学习这一章，终端最后输出用法废弃先不管，下一章再去研究Buffer对象。




## 内存泄露
 Nodejs 擅长高并发场景，同样也对内存泄露特别敏感，而且通常无意间造成的问题难以排查，但基本原因都是因为本该回收的对象没有回收以至于变成常驻老生代对象，可能原因有几个：
* 缓存
* 队列消费不及时
* 作用域未释放

###缓存
缓存是一种十分有效节省资源的手段，缓存也分多种，有严格意义上的有完善过期策略缓存，也有开发者代码常用的普通对象键值对缓存等，可能如下。
```
var cache = {},
    get = function(key, val) {
        return cache[key] ? cache[key] : cache[key] = val;
    };

console.log(get('ac', 12));
console.log(get('ac', 12));
console.log('cache: ', cache);
//12
//12
//cache:  { ac: 12 }
```
LS4
如果没做基本限制使用条件，在浏览器这种短时应用场景问题不大，但在 Nodejs 这种执行量大和参数多样性的使用环境会造成占用过多内存不释放，所以务必需要非常谨慎。

1，缓存限制策略
为了解决缓存对象永远无法释放的问题，需要加入一种策略限制缓存的无限增长。懒得写了，直接搬朴灵写的limitablemap模块实现写法。
```
var LimitableMap = function(limit) {
    this.limit = limit || 10;
    this.map = {};
    this.keys = [];
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
LimitableMap.prototype.set = function(key, value) {
    var map = this.map;
    var keys = this.keys;
    if (!hasOwnProperty.call(map, key)) {
        if (keys.length === this.limit) {
            var firstKey = keys.shift();
            delete map[firstKey];
        }
        keys.push(key);
    }
    map[key] = value;
};
LimitableMap.prototype.get = function(key) {
    return this.map[key];
};
module.exports = LimitableMap;
```
基本原理就是设置一个阈值，每当达到阈值的时候就移除头部缓存。

还有其他如模块机制的缓存是常驻老生代的对象，上一章节讲过 Nodejs 会将编译执行过后的模块缓存起来，然后可以通过 exports 变量访问里面的私有变量，导致私有变量作用域因为模块缓存原因不会被释放，而且外部也能够让私有变量不断增加占用内存。
```
(function(exports, require, module, __filename, __dirname) {
    var ary = [];
    exports.get = function() {
        return ary;
    };
    exports.add = function(val) {
        ary.push(val);
    };
});
```
一般解决方案就是同时导出一个清理缓存的方法。


### 缓存解决方案
因为进程之间无法共享内存，所以进程间不可避免有些重复缓存，目前比较好的方案是采用进程外的缓存。

* 缓存转移到外部减少常驻内存对象数量，提高GC效率
* 进程可以共享外部缓存

广为人知的有 [Redis](https://github.com/NodeRedis/node_redis) 和 [Memcached](https://github.com/3rd-Eden/memcached)，以后有机会补充进来相关用法。



## 队列状态
JS中我们也经常使用队列来控制事件，如果消费速度远低于生产速度就会形成堆积最后形成内存泄漏。
例如有些应用会采用数据库记录海量日志，而数据库又构建在文件系统之上而写入效率远低于直接写入文件系统，于是写入操作慢慢堆积导致相关作用域得不到释放占用大量内存最后出现内存泄漏，最简单解决方法就是换用文件写入日志的方式。
这是提高消费速度的情况，自然也会有需要抑制生产速度的情况出现。
深度解决方案有
* 监控队列长度，达到阈值通过监控系统报警并通知相关人员
* 超时机制，保证限定时间内未完成响应调用相关操作终止
* 拒绝模式，达到阈值之后不再接收新的生产事件


## 内存泄漏排查
*  node-heapdump 这是Node 核心贡献者之一Ben Noordhuis编写的模块，它允许对V8对堆内存抓取快照，用于事后分析。
*  node-memwatch 来自Mozilla的Lloyd Hilaiel贡献的模块，采用WTFPL许可发布。

试了一下安装很麻烦，总是报错，好像需要安装些其他依赖环境，编译插件，暂时放弃了，以后研究到再补充进来。


## 大内存应用
 Nodejs 提供了 Stream模块 用于处理大文件，它继承自 EventEmitter ，所以具备基本的自定义事件功能，同时抽象出标准的事件和方法， Nodejs 大多数模块都会用到 Stream模块，得益于它实现方式不受V8内存限制，能够有效提高代码健壮性。

因为稍后也准备写一篇关于Stream模块的东西，这里就不再说了，如果内容不多的话就搭配Buffer模块一起了。
