#Nodejs異步編程方法

##發佈訂閲模式
我在以前寫過一篇介紹異步方法的文章裏也提到過,而nodejs裏提供了一個單獨模塊events,大多数 Node.js 核心 API 都采用惯用的异步事件驱动架构，其中某些类型的对象（触发器）会周期性地触发命名事件来调用函数对象（监听器）。
例如，net.Server 对象会在每次有新连接时触发事件；fs.ReadStream 会在文件被打开时触发事件；流对象 会在数据可读时触发事件。
所有能触发事件的对象都是 EventEmitter 类的实例。 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数绑定到会被对象触发的命名事件上。

const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//監聽
myEmitter.on('event', () => {
    console.log('触发了一个事件！');
});
//觸發
myEmitter.emit('event');

###异步与同步
EventEmitter 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。 监听器函数可以使用 setImmediate() 或 process.nextTick() 方法切换到异步操作模式：
const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//監聽
myEmitter.on('event', () => {
    console.log('1');
});
//監聽
myEmitter.on('event', () => {
    setImmediate(() => {
        console.log('2');
    });
});
//監聽
myEmitter.on('event', () => {
    console.log('3');
});
//觸發
myEmitter.emit('event');

###错误事件
EventEmitter 有時候也會發生錯誤,如果沒有監聽"error"事件的話会抛出错误、打印堆栈跟踪、且退出 Node.js 进程,所以應該始終注册一个监听器
const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//監聽
myEmitter.on('error', (err) => {
    console.error('有错误');
});
myEmitter.emit('error', new Error('whoops!'));

###動態注冊監聽事件
EventEmitter 实例会在一个监听器被添加到其内部监听器数组之前触发自身的監聽事件,如果該监听器的名字和已有监听器名称相同, 则在被插入到EventEmitter实例的内部监听器数组时, 该监听器会被添加到其它同名监听器的前面。

const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
// 只处理一次，所以不会无限循环
myEmitter.once('newListener', (event, listener) => {
    if (event === 'event') {
        // 在开头插入一个新的监听器
        myEmitter.on('event', () => {
            console.log('B');
        });
    }
});
myEmitter.on('event', () => {
    console.log('A');
});
myEmitter.emit('event');
// 打印:
//   B
//   A

你可以試試把一次性監once聽換成普通監聽on方法看什麽效果.
