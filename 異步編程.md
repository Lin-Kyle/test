#Nodejs異步編程方法
##nodejs原生方法
我们以读取文件为例,读取文件名依赖前一个读取文件内容决定,nodejs提供的fs模块可以这么写
//nodejs.js
var fs = require("fs");
 
// 异步读取
fs.readFile('data1.txt', 'utf8', function(err, data1) {
    if (err) {
        return console.error(err);
    }
    console.log("第一次异步读取: " + data1.toString());
    fs.readFile(data1.toString().trim(), 'utf8', function(err, data2) {
        if (err) {
            return console.error(err);
        }
        console.log("第二次异步读取: " + data2.toString());

        fs.readFile(data2.toString().trim(), 'utf8', function(err, data3) {
            if (err) {
                return console.error(err);
            }
            console.log("第三次异步读取: " + data3.toString());
        });
    });
});
正如我前面介绍过[Nodejs高性能原理与异步非阻塞事件驱动模型与非异步API浅谈](https://www.qdfuns.com/article/40831/61e9532280ccc02dab21e47165c322d3.html),Nodejs单綫程事件驱动、非阻塞式 I/O的强大性能优势,但是异步编程也会带来一些问题,例如:
1, 地狱回调;
2, 外层无法捕获错误;
3, 无法利用多线程优势;
4, 编写习惯可能不符合部分人群;

##發佈訂閲模式
nodejs裏提供了一個單獨模塊events,大多数 Node.js 核心 API 都采用惯用的异步事件驱动架构，其中某些类型的对象（触发器）会周期性地触发命名事件来调用函数对象（监听器）。
例如，net.Server 对象会在每次有新连接时触发事件；fs.ReadStream 会在文件被打开时触发事件；流对象 会在数据可读时触发事件。
所有能触发事件的对象都是 EventEmitter 类的实例。 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数绑定到会被对象触发的命名事件上。

const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//監聽
myEmitter.on('event', () => {
    console.log('触发了一个事件！');
});
//觸發
myEmitter.emit('event');

###异步与同步
EventEmitter 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。 监听器函数可以使用 setImmediate() 或 process.nextTick() 方法切换到异步操作模式：
const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//監聽
myEmitter.on('event', () => {
    console.log('1');
});
//監聽
myEmitter.on('event', () => {
    setImmediate(() => {
        console.log('2');
    });
});
//監聽
myEmitter.on('event', () => {
    console.log('3');
});
//觸發
myEmitter.emit('event');

###错误事件
EventEmitter 有時候也會發生錯誤,如果沒有監聽"error"事件的話会抛出错误、打印堆栈跟踪、且退出 Node.js 进程,所以應該始終注册一个监听器
const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//監聽
myEmitter.on('error', (err) => {
    console.error('有错误');
});
myEmitter.emit('error', new Error('whoops!'));

###動態監聽每次注冊/移除事件
EventEmitter 实例会在一个监听器被添加到其内部监听器数组之前触发自身的 'newListener' 事件,在'newListener' 回调函数中, 如果該监听器的名字和已有监听器名称相同, 则在被插入到EventEmitter实例的内部监听器数组时, 该监听器会被添加到其它同名监听器的前面。

const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
// 只处理一次，所以不会无限循环
myEmitter.once('newListener', (event, listener) => {
    if (event === 'event') {
        // 在开头插入一个新的监听器
        myEmitter.on('event', () => {
            console.log('B');
        });
    }
});
myEmitter.on('event', () => {
    console.log('A');
});
myEmitter.emit('event');
// 打印:
//   B
//   A
你可以試試把一次性監once聽換成普通監聽on方法看什麽效果.


removeListener事件在 listener 被移除后触发,返回移除的eventName和listener
const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//每个注册/移除事件都会触发
myEmitter.on('newListener', (event, listener) => {
    console.log(event, listener);
}).on('removeListener', (event, listener) => {
    console.log(event, listener);
})
//注册/移除
myEmitter.on('abc', () => {
    console.log('注册abc事件!');
}).off('abc', () => {});

<!-- 注册removeListener事件
removeListener (event, listener) => {
    console.log(event, listener);
}
移除abc事件
abc () => {
    console.log('注册abc事件!');
} -->



其余API都没什么好讲的可以直接查看文档.
[Node.js v10.5.0 文档](http://nodejs.cn/api/events.html#events_emitter_off_eventname_listener)
[Node.js v10.5.0 Documentation](https://nodejs.org/dist/latest-v10.x/docs/api/events.html#events_event_newlistener)


###修改版
虽然不是很适合的例子,但是上面的原生代码可以类似这么改
const EventEmitter = require('events');
const fs = require("fs");

//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//監聽
myEmitter.on('data1', (file) => {
    fs.readFile(file, 'utf8', function(err, data) {
        if (err) {
            return console.error(err);
        }
        console.log("第一次异步读取: " + data.toString());
        myEmitter.emit('data2', data.toString().trim());
    });
}).on('data2', (file) => {
    fs.readFile(file, 'utf8', function(err, data) {
        if (err) {
            return console.error(err);
        }
        console.log("第二次异步读取: " + data.toString());
        myEmitter.emit('data3', data.toString().trim());
    });
}).on('data3', (file) => {
    fs.readFile(file, 'utf8', function(err, data) {
        if (err) {
            return console.error(err);
        }
        console.log("第三次异步读取: " + data.toString());
        myEmitter.emit('data3', data.toString().trim());
    });
}).on('error', (err) => {
    console.error('有错误');
});

//觸發
myEmitter.emit('data1', 'data1.txt');




##EventProxy.js
[EventProxy中文](http://eventproxy.html5ify.com/index.html)
[eventproxy](https://github.com/JacksonTian/eventproxy/blob/master/README_en.md)

> EventProxy 仅仅是一个很轻量的工具，但是能够带来一种事件式编程的思维变化。有几个特点：

>利用事件机制解耦复杂业务逻辑
移除被广为诟病的深度callback嵌套问题
将串行等待变成并行等待，提升多异步协作场景下的执行效率
友好的Error handling
无平台依赖，适合前后端，能用于浏览器和Node.js
兼容CMD，AMD以及CommonJS模块环境

###解决嵌套问题
//回调写法
var render = function (template, data) {
  _.template(template, data);
};
$.get("template", function (template) {
  // something
  $.get("data", function (data) {
    // something
    $.get("l10n", function (l10n) {
      // something
      render(template, data, l10n);
    });
  });

//EventProxy写法
var ep = EventProxy.create("template", "data", "l10n", function (template, data, l10n) {
  _.template(template, data, l10n);
});

$.get("template", function (template) {
  // something
  ep.emit("template", template);
});
$.get("data", function (data) {
  // something
  ep.emit("data", data);
});
$.get("l10n", function (l10n) {
  // something
  ep.emit("l10n", l10n);
});

有种和上面等价的快速创建all函数的方法
var ep = EventProxy.create('tpl', 'data', function (tpl, data) {
  // TODO
});


###异步协作
1, 多类型异步协作
我们可以使用all方法将handler注册到事件组合上。当注册的多个事件都触发后，将会调用handler执行，每个事件传递的数据，将会依照事件名顺序，传入handler作为参数。
var ep = new EventProxy();
ep.all('tpl', 'data', function (tpl, data) {
  // 在所有指定的事件触发后，将会被调用执行
  // 参数对应各自的事件名
});
fs.readFile('template.tpl', 'utf-8', function (err, content) {
  ep.emit('tpl', content);
});
db.get('some sql', function (err, result) {
  ep.emit('data', result);
});

2, 重复异步协作
after方法适合重复的操作,将handler注册到N次相同事件的触发上。达到指定的触发数，handler将会被调用执行，每次触发的数据，将会按触发顺序，存为数组作为参数传入。
var ep = new EventProxy();
ep.after('got_file', files.length, function (list) {
  // 在所有文件的异步执行结束后将被执行
  // 所有文件的内容都存在list数组中
});
for (var i = 0; i < files.length; i++) {
  fs.readFile(files[i], 'utf-8', function (err, content) {
    // 触发结果事件
    ep.emit('got_file', content);
  });
}

3, 持续型异步协作
tail方法在指定事件都触发之后，如果事件依旧持续触发，将会在每次触发时调用handler。
var ep = new EventProxy();
ep.tail('tpl', 'data', function (tpl, data) {
  // 在所有指定的事件触发后，将会被调用执行
  // 参数对应各自的事件名的最新数据
});
fs.readFile('template.tpl', 'utf-8', function (err, content) {
  ep.emit('tpl', content);
});
setInterval(function () {
  db.get('some sql', function (err, result) {
    ep.emit('data', result);
  });
}, 2000);


但是这些方式都不适合依赖型需求,所以不适用我那个依赖读取文件内容的代码.


###异常处理
* fail方法侦听了error事件，默认处理卸载掉所有handler，并调用回调函数。
ep.fail(callback);
// 由于参数位相同，它实际是
ep.fail(function (err) {
  callback(err);
});

// 等价于
ep.bind('error', function (err) {
  // 卸载掉所有handler
  ep.unbind();
  // 异常回调
  callback(err);
});


* done方法,在Node的最佳实践中，回调函数第一个参数一定会是一个error对象。检测到异常后，将会触发error事件。剩下的参数，将触发事件，传递给对应handler处理。done方法除了接受事件名外，还接受回调函数。如果是函数时，它将剔除第一个error对象(此时为null)后剩余的参数，传递给该回调函数作为参数。该回调函数无需考虑异常处理。
ep.done('tpl',  () =>  {});
// 等价于
function (err, content) {
  if (err) {
    // 一旦发生异常，一律交给error事件的handler处理
    return ep.emit('error', err);
  }
  ep.emit('tpl', content);
}

* group方法,在after的回调函数中，结果顺序是与用户emit的顺序有关。为了满足返回数据按发起异步调用的顺序排列，EventProxy提供了group方法,当回调函数的数据还需要进行加工时，可以给group带上回调函数，只要在操作后将数据返回即可
ep.group('got_file',() => {});
// 约等价于
function (err, data) {
  if (err) {
    return ep.emit('error', err);
  }
  ep.emit('got_file', data);
};


###异步事件触发: emitLater && doneLater
var ep = EventProxy.create();

db.check('key', function (err, permission) {
  if (err) {
    return ep.emit('error', err);
  }
  ep.emit('check', permission);
});

ep.once('check', function (permission) {
  permission && db.get('key', function (err, data) {
    if (err) {
      return ep.emit('error');
    }
    ep.emit('get', data);
  });
});

ep.once('get', function (err, data) {
  if (err) {
    return ep.emit('error', err);
  }
  render(data);
});

ep.on('error', errorHandler);

看不太懂没关系,我直接跟你说,尽管node的约定是所有的callback都是需要异步返回的，但是如果这个方法是由第三方提供的，我们没有办法保证db.check的callback一定会异步执行，如果db.check('key')在ep.once('check')监听之前执行,会无法执行后续操作,所以我们需要用异步事件触发
db.check('key', function (err, permission) {
  if (err) {
    return ep.emitLater('error', err);
  }
  ep.emitLater('check', permission);
});
这样,就算db.check的回调函数被同步执行了，事件的触发也还是异步的，ep在当前事件循环中监听了所有的事件，之后的事件循环中才会去触发check事件。代码顺序将和逻辑顺序保持一致。
也可以像ep.done()一样通过doneLater来解决.
var ep = EventProxy.create();

db.check('key', ep.doneLater('check'));

ep.once('check', function (permission) {
  permission && db.get('key', ep.done('get'));
});

ep.once('get', function (data) {
  render(data);
});

ep.fail(errorHandler);






##async.js
[async.js](https://caolan.github.io/async/)
async是一个强大实用的异步库,提供多达70+API,包括一些常用的功能函数 (map, reduce, filter, each…)和流程控制函数(parallel, series, waterfall…),所有方法都假定你遵循nodejs约定:
1, 提供一个回调函数作为最后入参;
2, 错误作为返回值第一个参数;
3, 只执行一次回调;

因为本身太大,可以根据需要按需加载.就拿两个方法来说说

###parallel(tasks, callbackopt)
并行运行任务不需要等待顺序执行,一旦发生错误就作为参数传递执行回调,否则执行完之后全部结果传递给回调函数.
注意: parallel是并行启动I/O任务，而不是并行执行代码。如果您的任务不使用任何计时器或执行任何I/O，它们实际上将以串行方式执行。
async.parallel([
    function(callback) {
        setTimeout(function() {
            callback(null, 'one');
        }, 200);
    },
    function(callback) {
        setTimeout(function() {
            callback(null, 'two');
        }, 100);
    }
],
// optional callback
function(err, results) {
    // the results array will equal ['one','two'] even though
    // the second function had a shorter timeout.
});

// an example using an object instead of an array
async.parallel({
    one: function(callback) {
        setTimeout(function() {
            callback(null, 1);
        }, 200);
    },
    two: function(callback) {
        setTimeout(function() {
            callback(null, 2);
        }, 100);
    }
}, function(err, results) {
    // results is now equals to: {one: 1, two: 2}
});



###waterfall(tasks, callbackopt)
串行执行代码并把当前函数结果作为下一个函数的入参,如果发生错误会终止执行后续函数把作为参数传递给回调函数执行.
async.waterfall([
    function(callback) {
        callback(null, 'one', 'two');
    },
    function(arg1, arg2, callback) {
        // arg1 now equals 'one' and arg2 now equals 'two'
        callback(null, 'three');
    },
    function(arg1, callback) {
        // arg1 now equals 'three'
        callback(null, 'done');
    }
], function (err, result) {
    // result now equals 'done'
});

// Or, with named functions:
async.waterfall([
    myFirstFunction,
    mySecondFunction,
    myLastFunction,
], function (err, result) {
    // result now equals 'done'
});
function myFirstFunction(callback) {
    callback(null, 'one', 'two');
}
function mySecondFunction(arg1, arg2, callback) {
    // arg1 now equals 'one' and arg2 now equals 'two'
    callback(null, 'three');
}
function myLastFunction(arg1, callback) {
    // arg1 now equals 'three'
    callback(null, 'done');
}



###auto(tasks, concurrencyopt, callbackopt)
根据任务的异步函数依赖需求决定最佳执行顺序,每个函数都能选择依赖其他先完成的函数并且满足条件之后立即执行.如果当中任何一个异步函数发生错误auto方法就会终止执行然后传递错误信息给回调函数执行.
有依赖性的话异步函数会接收包含已完成的函数结果作为第一个参数,否则只传递回调函数.
async.auto({
    // this function will just be passed a callback
    readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
    showData: ['readData', function(results, cb) {
        // results.readData is the file's contents
        // ...
    }]
}, callback);

async.auto({
    get_data: function(callback) {
        console.log('in get_data');
        // async code to get some data
        callback(null, 'data', 'converted to array');
    },
    make_folder: function(callback) {
        console.log('in make_folder');
        // async code to create a directory to store a file in
        // this is run at the same time as getting the data
        callback(null, 'folder');
    },
    write_file: ['get_data', 'make_folder', function(results, callback) {
        console.log('in write_file', JSON.stringify(results));
        // once there is some data and the directory exists,
        // write the data to a file in the directory
        callback(null, 'filename');
    }],
    email_link: ['write_file', function(results, callback) {
        console.log('in email_link', JSON.stringify(results));
        // once the file is written let's email a link to it...
        // results.write_file contains the filename returned by write_file.
        callback(null, {'file':results.write_file, 'email':'user@example.com'});
    }]
}, function(err, results) {
    console.log('err = ', err);
    console.log('results = ', results);
});


###mapLimit(coll, limit, iteratee, callbackopt)
提供一个遍历任务集合进行并行操作,执行顺序不保证,但是返回结果不管集合是数组还是对象,统一返回任务顺序的结果数组.并且提供最大并发数,但是iteratee任何一次错误都会终止执行并且传输err给回调函数执行
async.mapLimit([],5,function(item,callback){
    callback(null,item);
},function(err,results){
   console.log(err, results);
});



###修改版
我们可以使用waterfall或者auto方法修改
var waterfall = require('async/waterfall'),
    auto = require('async/auto'),
    fs = require('fs');

/*waterfall([
    function(callback) {
        fs.readFile('data1.txt', 'utf8', function(err, data) {
            if (err) {
                return console.error(err);
            }
            console.log("第一次异步读取: " + data.toString());
            callback(null, data.toString().trim());
        });
    },
    function(file, callback) {
        fs.readFile(file, 'utf8', function(err, data) {
            if (err) {
                return console.error(err);
            }
            console.log("第二次异步读取: " + data.toString());
            callback(null, data.toString().trim());
        });
    },
    function(file) {
        fs.readFile(file, 'utf8', function(err, data) {
            if (err) {
                return console.error(err);
            }
            console.log("第三次异步读取: " + data.toString());
        });
    }
], function(err, result) {
    // result now equals 'done'
});*/

//OR

auto({
    data1: function(callback) {
        fs.readFile('data1.txt', 'utf8', function(err, data) {
            if (err) {
                return console.error(err);
            }
            console.log("第一次异步读取: " + data.toString());
            callback(null, data.toString().trim());
        });
    },
    data2: [
        'data1',
        function(file, callback) {
            fs.readFile(file.data1, 'utf8', function(err, data) {
                if (err) {
                    return console.error(err);
                }
                console.log("第二次异步读取: " + data.toString());
                callback(null, data.toString().trim());
            });
        }
    ],
    data3: [
        'data2',
        function(file) {
            fs.readFile(file.data2, 'utf8', function(err, data) {
                if (err) {
                    return console.error(err);
                }
                console.log("第三次异步读取: " + data.toString());
            });
        }
    ]
}, function(err, result) {
    // result now equals 'done'
});






#異步并發控制
##Bagpipe
[Bagpipe](http://html5ify.com/bagpipe/#index_API)
Bagpipe通过push将调用传入内部队列。如果活跃调用小于最大并发数，将会被取出直接执行，反之则继续呆在队列中。当一个异步调用结束的时候，会从队列前取出调用执行。以此来保证异步调用的活跃量不高于限定值。
当队列的长度大于100或者大于最大并发数的2倍时，Bagpipe对象将会触发它的full事件，该事件传递队列长度值。


例如当你需要遍历文件目录的时候，异步可以确保充分利用IO。你可以轻松发起成千上万个文件的读取。但是，系统文件描述符是有限的。
var bagpipe = new Bagpipe(10);

var files = ['这里有很多很多文件'];
for (var i = 0; i < files.length; i++) {
  // fs.readFile(files[i], 'utf-8', function (err, data) {
  bagpipe.push(fs.readFile, files[i], 'utf-8', function (err, data) {
    // 不会因为文件描述符过多出错
    // 妥妥的
  });
}
bagpipe.on('full', function (length) {
  console.warn('底层系统处理不能及时完成，队列拥堵，目前队列长度为:' + length);
});
