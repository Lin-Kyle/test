#Nodejs異步編程方法

##發佈訂閲模式
我在以前寫過一篇介紹異步方法的文章裏也提到過,而nodejs裏提供了一個單獨模塊events,大多数 Node.js 核心 API 都采用惯用的异步事件驱动架构，其中某些类型的对象（触发器）会周期性地触发命名事件来调用函数对象（监听器）。
例如，net.Server 对象会在每次有新连接时触发事件；fs.ReadStream 会在文件被打开时触发事件；流对象 会在数据可读时触发事件。
所有能触发事件的对象都是 EventEmitter 类的实例。 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数绑定到会被对象触发的命名事件上。

const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//監聽
myEmitter.on('event', () => {
    console.log('触发了一个事件！');
});
//觸發
myEmitter.emit('event');

###异步与同步
EventEmitter 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。 监听器函数可以使用 setImmediate() 或 process.nextTick() 方法切换到异步操作模式：
const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//監聽
myEmitter.on('event', () => {
    console.log('1');
});
//監聽
myEmitter.on('event', () => {
    setImmediate(() => {
        console.log('2');
    });
});
//監聽
myEmitter.on('event', () => {
    console.log('3');
});
//觸發
myEmitter.emit('event');

###错误事件
EventEmitter 有時候也會發生錯誤,如果沒有監聽"error"事件的話会抛出错误、打印堆栈跟踪、且退出 Node.js 进程,所以應該始終注册一个监听器
const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//監聽
myEmitter.on('error', (err) => {
    console.error('有错误');
});
myEmitter.emit('error', new Error('whoops!'));

###動態監聽每次注冊/移除事件
EventEmitter 实例会在一个监听器被添加到其内部监听器数组之前触发自身的 'newListener' 事件,在'newListener' 回调函数中, 如果該监听器的名字和已有监听器名称相同, 则在被插入到EventEmitter实例的内部监听器数组时, 该监听器会被添加到其它同名监听器的前面。

const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
// 只处理一次，所以不会无限循环
myEmitter.once('newListener', (event, listener) => {
    if (event === 'event') {
        // 在开头插入一个新的监听器
        myEmitter.on('event', () => {
            console.log('B');
        });
    }
});
myEmitter.on('event', () => {
    console.log('A');
});
myEmitter.emit('event');
// 打印:
//   B
//   A
你可以試試把一次性監once聽換成普通監聽on方法看什麽效果.


removeListener事件在 listener 被移除后触发,返回移除的eventName和listener
const EventEmitter = require('events');
//創建類
class MyEmitter extends EventEmitter {}
//實例化
const myEmitter = new MyEmitter();
//每个注册/移除事件都会触发
myEmitter.on('newListener', (event, listener) => {
    console.log(event, listener);
}).on('removeListener', (event, listener) => {
    console.log(event, listener);
})
//注册/移除
myEmitter.on('abc', () => {
    console.log('注册abc事件!');
}).off('abc', () => {});

<!-- 注册removeListener事件
removeListener (event, listener) => {
    console.log(event, listener);
}
移除abc事件
abc () => {
    console.log('注册abc事件!');
} -->



其余API都没什么好讲的可以直接查看文档.
[Node.js v10.5.0 文档](http://nodejs.cn/api/events.html#events_emitter_off_eventname_listener)
[Node.js v10.5.0 Documentation](https://nodejs.org/dist/latest-v10.x/docs/api/events.html#events_event_newlistener)



##EventProxy
[EventProxy中文](http://eventproxy.html5ify.com/index.html)
[eventproxy](https://github.com/JacksonTian/eventproxy/blob/master/README_en.md)

> EventProxy 仅仅是一个很轻量的工具，但是能够带来一种事件式编程的思维变化。有几个特点：

>利用事件机制解耦复杂业务逻辑
移除被广为诟病的深度callback嵌套问题
将串行等待变成并行等待，提升多异步协作场景下的执行效率
友好的Error handling
无平台依赖，适合前后端，能用于浏览器和Node.js
兼容CMD，AMD以及CommonJS模块环境

###解决嵌套问题
//回调写法
const render = function(template, data) {
    _.template(template, data);
};
$.get("template", template => {
    $.get("data", data => {});
});


//EventProxy写法
const ep = EventProxy.create("template", "data", (template, data) => {
    _.template(template, data, l10n);
});

$.get("template", template => {
    ep.emit("template", template);
});
$.get("data", data => {
    ep.emit("data", data);
});


###异步协作
1, 多类型异步协作
我们可以使用all方法将handler注册到事件组合上。当注册的多个事件都触发后，将会调用handler执行，每个事件传递的数据，将会依照事件名顺序，传入handler作为参数。
var ep = new EventProxy();
ep.all('tpl', 'data', function (tpl, data) {
  // 在所有指定的事件触发后，将会被调用执行
  // 参数对应各自的事件名
});
fs.readFile('template.tpl', 'utf-8', function (err, content) {
  ep.emit('tpl', content);
});
db.get('some sql', function (err, result) {
  ep.emit('data', result);
});

2, 重复异步协作
after方法适合重复的操作,将handler注册到N次相同事件的触发上。达到指定的触发数，handler将会被调用执行，每次触发的数据，将会按触发顺序，存为数组作为参数传入。
var ep = new EventProxy();
ep.after('got_file', files.length, function (list) {
  // 在所有文件的异步执行结束后将被执行
  // 所有文件的内容都存在list数组中
});
for (var i = 0; i < files.length; i++) {
  fs.readFile(files[i], 'utf-8', function (err, content) {
    // 触发结果事件
    ep.emit('got_file', content);
  });
}

3, 持续型异步协作
tail方法在指定事件都触发之后，如果事件依旧持续触发，将会在每次触发时调用handler。
var ep = new EventProxy();
ep.tail('tpl', 'data', function (tpl, data) {
  // 在所有指定的事件触发后，将会被调用执行
  // 参数对应各自的事件名的最新数据
});
fs.readFile('template.tpl', 'utf-8', function (err, content) {
  ep.emit('tpl', content);
});
setInterval(function () {
  db.get('some sql', function (err, result) {
    ep.emit('data', result);
  });
}, 2000);


###异常处理
* fail方法侦听了error事件，默认处理卸载掉所有handler，并调用回调函数。
ep.fail(callback);
// 由于参数位相同，它实际是
ep.fail(function (err) {
  callback(err);
});

// 等价于
ep.bind('error', function (err) {
  // 卸载掉所有handler
  ep.unbind();
  // 异常回调
  callback(err);
});


* done方法,在Node的最佳实践中，回调函数第一个参数一定会是一个error对象。检测到异常后，将会触发error事件。剩下的参数，将触发事件，传递给对应handler处理。done方法除了接受事件名外，还接受回调函数。如果是函数时，它将剔除第一个error对象(此时为null)后剩余的参数，传递给该回调函数作为参数。该回调函数无需考虑异常处理。
ep.done('tpl',  () =>  {});
// 等价于
function (err, content) {
  if (err) {
    // 一旦发生异常，一律交给error事件的handler处理
    return ep.emit('error', err);
  }
  ep.emit('tpl', content);
}

* group方法,在after的回调函数中，结果顺序是与用户emit的顺序有关。为了满足返回数据按发起异步调用的顺序排列，EventProxy提供了group方法,当回调函数的数据还需要进行加工时，可以给group带上回调函数，只要在操作后将数据返回即可
ep.group('got_file',() => {});
// 约等价于
function (err, data) {
  if (err) {
    return ep.emit('error', err);
  }
  ep.emit('got_file', data);
};


###异步事件触发: emitLater && doneLater



##Promise()



##connect



##async




##step






#異步并發控制
##bagpipe
